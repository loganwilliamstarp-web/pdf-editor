<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Certificate Management System</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>PDF</text></svg>">
    <script src="https://cdn.tailwindcss.com" defer></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
</head>
<body>
    <div class="min-h-screen bg-gray-100">
        <header class="bg-white shadow-sm">
            <div class="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8 flex justify-between items-center">
                <h1 class="text-2xl font-bold text-gray-900">
                    Certificate Management System <span class="text-gray-500 text-sm" id="accountId">Loading...</span>
                </h1>
                <nav class="flex space-x-4">
                    <button onclick="showTab('master')" id="masterTab" class="px-3 py-2 rounded-md text-sm font-medium bg-indigo-600 text-white">
                        Master Certificates
                    </button>
                    <button onclick="showTab('holders')" id="holdersTab" class="px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50">
                        Certificate Holders
                    </button>
                    <button onclick="showTab('generated')" id="generatedTab" class="px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50">
                        Generated Certificates
                    </button>
                </nav>
            </div>
        </header>

        <main class="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
            <!-- Master Certificates Tab -->
            <div id="masterContent" class="bg-white shadow overflow-hidden sm:rounded-lg p-6">
                <h2 class="text-xl font-semibold text-gray-900 mb-4">Master Certificates (Templates)</h2>
                
                <div id="templatesList">
                    <p class="text-gray-600">Loading templates...</p>
                </div>
            </div>

            <!-- Certificate Holders Tab -->
            <div id="holdersContent" class="bg-white shadow overflow-hidden sm:rounded-lg p-6" style="display: none;">
                <h2 class="text-xl font-semibold text-gray-900 mb-4">Certificate Holders</h2>
                <p class="text-gray-600">This section will allow you to manage recipients of certificates. (Coming soon!)</p>
            </div>

            <!-- Generated Certificates Tab -->
            <div id="generatedContent" class="bg-white shadow overflow-hidden sm:rounded-lg p-6" style="display: none;">
                <h2 class="text-xl font-semibold text-gray-900 mb-4">Generated Certificates</h2>
                <p class="text-gray-600">This section will display certificates generated from templates for specific holders. (Coming soon!)</p>
            </div>
        </main>
    </div>

    <script>
        // Get account ID from URL
        function getAccountId() {
            const path = window.location.pathname;
            const pathParts = path.split('/').filter(part => part);
            return pathParts[0] || '001000000000001';
        }

        // Initialize the app
        function initApp() {
            const accountId = getAccountId();
            document.getElementById('accountId').textContent = `(${accountId})`;
            loadTemplates();
        }

        // Show tab content
        function showTab(tab) {
            // Hide all content
            document.getElementById('masterContent').style.display = 'none';
            document.getElementById('holdersContent').style.display = 'none';
            document.getElementById('generatedContent').style.display = 'none';
            
            // Remove active class from all tabs
            document.getElementById('masterTab').className = 'px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50';
            document.getElementById('holdersTab').className = 'px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50';
            document.getElementById('generatedTab').className = 'px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50';
            
            // Show selected content and highlight tab
            document.getElementById(tab + 'Content').style.display = 'block';
            document.getElementById(tab + 'Tab').className = 'px-3 py-2 rounded-md text-sm font-medium bg-indigo-600 text-white';
        }

        // Load templates
        async function loadTemplates() {
            try {
                const accountId = getAccountId();
                console.log('Loading templates for account:', accountId);
                const response = await fetch(`/api/account/${accountId}/templates`);
                const data = await response.json();
                console.log('Templates response:', data);
                
                const templatesList = document.getElementById('templatesList');
                if (data.success && data.templates && data.templates.length > 0) {
                    templatesList.innerHTML = `
                        <ul class="divide-y divide-gray-200">
                            ${data.templates.map(template => `
                                <li class="py-4 flex items-center justify-between">
                                    <div class="flex items-center">
                                        <div class="w-6 h-6 text-gray-500 mr-3">PDF</div>
                                        <div>
                                            <p class="text-sm font-medium text-gray-900">${template.template_name}</p>
                                            <p class="text-sm text-gray-500">Type: ${template.template_type}</p>
                                        </div>
                                    </div>
                                    <button onclick="editTemplate('${template.id}')" class="inline-flex items-center px-3 py-1.5 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700">
                                        Edit
                                    </button>
                                </li>
                            `).join('')}
                        </ul>
                    `;
                } else {
                    templatesList.innerHTML = '<p class="text-gray-600">No templates found.</p>';
                }
            } catch (error) {
                console.error('Error loading templates:', error);
                document.getElementById('templatesList').innerHTML = `<p class="text-red-600">Error loading templates: ${error.message}</p>`;
            }
        }

        // Edit template with Adobe PDF Editor (Popup Window)
        function editTemplate(templateId) {
            openPDFEditorWindow(templateId);
        }

        // Open PDF Editor in Popup Window
        function openPDFEditorWindow(templateId) {
    const accountId = getAccountId();
    const windowFeatures = 'width=1200,height=800,scrollbars=yes,resizable=yes,toolbar=no,menubar=no,location=no,status=no';
    const popupWindow = window.open('', `pdfEditor_${templateId}`, windowFeatures);

    if (!popupWindow) {
        alert('Popup blocked! Please allow popups for this site and try again.');
        return;
    }

    const popupHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>PDF Editor - Template</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>PDF</text></svg>">
</head>
<body class="bg-gray-100">
    <div class="h-screen flex flex-col">
        <!-- Header -->
        <header class="bg-white shadow-sm border-b">
            <div class="px-6 py-4 flex justify-between items-center">
                <h1 class="text-xl font-semibold text-gray-900">PDF Editor</h1>
                <div class="flex space-x-3">
                    <button id="saveBtn" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-400 hover:bg-gray-500" disabled>Save PDF (Use Ctrl+S)</button>
                    <button id="downloadBtn" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700">Download PDF</button>
                    <button id="closeBtn" class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50">Close</button>
                </div>
            </div>
        </header>

        <!-- Info Bar -->
        <div class="bg-blue-50 border-b px-6 py-3">
            <p class="text-sm text-blue-800">
                <strong>PDF Editor:</strong> Click on any field in the PDF to edit it directly.
                <strong>Press Ctrl+S directly in the PDF viewer</strong> to save your changes to the database.
            </p>
        </div>

        <!-- PDF Container -->
        <div class="flex-1 p-6">
            <div id="pdfEditorContainer" class="h-full border border-gray-300 rounded-lg bg-white">
                <!-- PDF Viewer -->
                <div id="adobe-dc-view" style="width: 100%; height: 100%;"></div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="bg-white border-t px-6 py-3">
            <div class="flex justify-between items-center">
                <div id="saveStatus" class="text-sm text-blue-600">Preparing Adobe PDF viewer...</div>
                <div class="text-xs text-gray-500">Press Ctrl+S directly in the PDF viewer to save</div>
            </div>
        </div>
    </div>
</body>
</html>`;

    popupWindow.document.open('text/html');
    popupWindow.document.write(popupHTML);
    popupWindow.document.close();

    initializePDFEditorPopup(popupWindow, { templateId, accountId, appOrigin: window.location.origin });

    popupWindow.focus();
}

function initializePDFEditorPopup(popupWindow, context) {
    const { templateId, accountId, appOrigin: forcedOrigin } = context;
    const doc = popupWindow.document;

    if (!doc) {
        console.error('[PDF Popup] document unavailable');
        return;
    }

    const appOrigin = forcedOrigin
        || (popupWindow.opener && popupWindow.opener.location && popupWindow.opener.location.origin)
        || (popupWindow.location && popupWindow.location.origin)
        || window.location.origin;
    console.log('[PDF Popup] init context', { templateId, accountId, appOrigin });

    popupWindow.PDF_DEBUG = popupWindow.PDF_DEBUG || {};
    popupWindow.PDF_DEBUG.context = { templateId, accountId, appOrigin };
    popupWindow.PDF_DEBUG.state = popupWindow.PDF_DEBUG.state || {};

    let currentPDFViewer = null;
    let currentPDFAPIs = null;
    popupWindow.PDF_DEBUG.state.viewerReady = false;
    
    // Manual save only - no polling or auto-save
    let isSaving = false;
    let savedFieldValues = null; // Store field values to apply when PDF loads

    const saveBtn = doc.getElementById('saveBtn');
    const downloadBtn = doc.getElementById('downloadBtn');
    const closeBtn = doc.getElementById('closeBtn');
    const saveStatusEl = doc.getElementById('saveStatus');
    const adobeContainer = doc.getElementById('adobe-dc-view');

    function setSaveStatus(status, message) {
        if (!saveStatusEl) {
            return;
        }
        saveStatusEl.className = 'text-sm';
        if (status === 'info') {
            saveStatusEl.classList.add('text-blue-600');
        } else if (status === 'success') {
            saveStatusEl.classList.add('text-green-600');
        } else if (status === 'error') {
            saveStatusEl.classList.add('text-red-600');
        }
        saveStatusEl.textContent = message;
    }

    // No auto-save status function needed

    popupWindow.addEventListener('error', function(event) {
        setSaveStatus('error', 'Runtime error: ' + event.message);
        if (event && event.error) {
            console.error('[PDF Popup] uncaught error', event.error);
        } else {
            console.error('[PDF Popup] uncaught error', event.message);
        }
    });

    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            popupWindow.close();
        });
    }

    if (saveBtn) {
        saveBtn.addEventListener('click', () => {
            // Save button is disabled - show instruction
            setSaveStatus('info', 'Please press Ctrl+S directly in the PDF viewer to save your changes.');
        });
    }

    if (downloadBtn) {
        downloadBtn.addEventListener('click', () => downloadPDF());
    }

    function ensureTailwindStyles() {
        if (popupWindow.tailwind) {
            console.log('[PDF Popup] Tailwind already available');
            return Promise.resolve();
        }

        const existing = doc.getElementById('tailwind-popup-script');
        if (existing) {
            console.log('[PDF Popup] Waiting for existing Tailwind script to load');
            return new Promise((resolve, reject) => {
                existing.addEventListener('load', () => resolve(), { once: true });
                existing.addEventListener('error', () => reject(new Error('Tailwind CDN failed to load')), { once: true });
            });
        }

        return new Promise((resolve, reject) => {
            console.log('[PDF Popup] Injecting Tailwind CDN script');
            const script = doc.createElement('script');
            script.id = 'tailwind-popup-script';
            script.src = 'https://cdn.tailwindcss.com';
            script.defer = true;
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Tailwind CDN failed to load'));
            doc.head.appendChild(script);
        });
    }

    function ensureAdobePDFSDK() {
        if (popupWindow.AdobeDC && popupWindow.AdobeDC.View) {
            console.log('[PDF Popup] Adobe SDK already available');
            return Promise.resolve();
        }

        const existing = doc.getElementById('adobe-pdf-viewer-sdk');
        if (existing) {
            console.log('[PDF Popup] Waiting for existing Adobe SDK script');
            return new Promise((resolve, reject) => {
                existing.addEventListener('load', () => resolve(), { once: true });
                existing.addEventListener('error', () => reject(new Error('Adobe PDF Embed API failed to load')), { once: true });
            });
        }

        return new Promise((resolve, reject) => {
            console.log('[PDF Popup] Injecting Adobe PDF Embed SDK script');
            const script = doc.createElement('script');
            script.id = 'adobe-pdf-viewer-sdk';
            script.src = 'https://acrobatservices.adobe.com/view-sdk/viewer.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Adobe PDF Embed API failed to load'));
            doc.head.appendChild(script);
        });
    }

    function showAdobeSDKError(localTemplateId) {
        if (!adobeContainer) {
            return;
        }
        adobeContainer.innerHTML = '<div class="h-full flex flex-col items-center justify-center bg-gray-50"><div class="text-center p-8"><div class="text-6xl mb-4">PDF</div><h3 class="text-lg font-semibold text-gray-900 mb-2">PDF Editor Ready</h3><p class="text-gray-600 mb-4">Template ID: ' + localTemplateId + '</p><div class="space-y-2 text-sm text-gray-500 mb-6"><p>-  Click on form fields to edit them</p><p>-  Use the Save Fields button to save your changes</p><p>-  Data is automatically saved to the database</p></div><div class="p-4 bg-blue-50 rounded-lg"><p class="text-blue-800 text-sm"><strong>Adobe PDF Embed API:</strong> Demo mode - Form fields are simulated for testing.</p></div></div></div>';
        setSaveStatus('info', 'Adobe viewer unavailable. Demo mode is active.');

        currentPDFViewer = {
            getFormFields: async function() {
                return {
                    company_name: 'Sample Company',
                    policy_number: 'POL-123456',
                    effective_date: '01/01/2025',
                    expiration_date: '12/31/2025',
                    insured_name: 'John Doe',
                    address: '123 Main St, City, State 12345'
                };
            },
            setFormFields: async function(fields) {
                console.log('[PDF Popup] Demo mode setting form fields', fields);
                return true;
            }
        };
    }

    function showPDFError(localTemplateId, errorMessage) {
        if (!adobeContainer) {
            return;
        }
        adobeContainer.innerHTML = '<div class="h-full flex flex-col items-center justify-center bg-gray-50"><div class="text-center p-8"><div class="text-6xl mb-4">Warning</div><h3 class="text-lg font-semibold text-gray-900 mb-2">PDF Loading Error</h3><p class="text-gray-600 mb-4">Template ID: ' + localTemplateId + '</p><p class="text-red-600 text-sm mb-6">Error: ' + errorMessage + '</p><div class="space-y-2 text-sm text-gray-500 mb-6"><p>-  PDF file may not be available</p><p>-  Check template storage configuration</p><p>-  Try refreshing the page</p></div><button id="retryLoadBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Retry Loading PDF</button></div></div>';

        const retryBtn = doc.getElementById('retryLoadBtn');
        if (retryBtn) {
            retryBtn.addEventListener('click', () => startViewer());
        }

        setSaveStatus('error', errorMessage || 'Failed to load the PDF template.');

        currentPDFViewer = {
            getFormFields: async function() {
                return {
                    company_name: 'Sample Company',
                    policy_number: 'POL-123456',
                    effective_date: '01/01/2025',
                    expiration_date: '12/31/2025',
                    insured_name: 'John Doe',
                    address: '123 Main St, City, State 12345'
                };
            },
            setFormFields: async function(fields) {
                console.log('[PDF Popup] Fallback: Setting form fields', fields);
                return true;
            }
        };
    }

    async function loadExistingFieldValues(localTemplateId) {
        try {
            const url = appOrigin + '/api/pdf/get-fields/' + localTemplateId + '/' + accountId;
            console.log('[PDF Popup] Loading field values from:', url);
            
            const response = await fetch(url);
            console.log('[PDF Popup] Load response status:', response.status);
            
            const data = await response.json();
            console.log('[PDF Popup] Load response data:', data);

            // Store server field definitions for fallback
            if (data.success && data.form_fields && Array.isArray(data.form_fields)) {
                const serverFields = {};
                data.form_fields.forEach(field => {
                    if (field.name) {
                        serverFields[field.name] = field.default_value || '';
                    }
                });
                popupWindow.PDF_DEBUG = popupWindow.PDF_DEBUG || {};
                popupWindow.PDF_DEBUG.serverFields = serverFields;
                console.log('[PDF Popup] Stored server field definitions:', Object.keys(serverFields).length);
            }

            if (data.success && data.field_values) {
                console.log('[PDF Popup] Loading existing field values', data.field_values);
                console.log('[PDF Popup] Field values keys:', Object.keys(data.field_values || {}));
                savedFieldValues = data.field_values; // Store for later application
                return data.field_values;
            } else {
                console.log('[PDF Popup] No existing field values found');
                console.log('[PDF Popup] Field values object:', data.field_values);
                savedFieldValues = null;
                return null;
            }
        } catch (error) {
            console.error('[PDF Popup] Error loading existing field values', error);
            savedFieldValues = null;
            return null;
        }
    }

    async function applySavedFieldValues(fieldValues) {
        if (!fieldValues || Object.keys(fieldValues).length === 0) {
            console.log('[PDF Popup] No field values to apply');
            setSaveStatus('info', 'PDF ready for editing. Save to store your changes.');
            return;
        }
        
        // Check if any fields have non-empty values
        const nonEmptyFields = Object.entries(fieldValues).filter(([key, value]) => value && String(value).trim() !== '');
        console.log('[PDF Popup] Non-empty fields to apply:', nonEmptyFields.length);
        
        if (nonEmptyFields.length === 0) {
            console.log('[PDF Popup] All field values are empty, skipping application');
            setSaveStatus('info', 'PDF ready for editing. Save to store your changes.');
            return;
        }

        console.log('[PDF Popup] Applying saved field values', fieldValues);

        // Wait for PDF to be fully loaded
        await new Promise(resolve => setTimeout(resolve, 2000));

        const adobeValueEntries = mapObjectToAdobeFormFieldValues(fieldValues);
                console.log('[PDF Popup] Prepared Adobe value entries', adobeValueEntries);

        // Method 1: Try Adobe API setFormFieldValues
                if (adobeValueEntries.length && currentPDFAPIs && currentPDFAPIs.setFormFieldValues) {
                    try {
                console.log('[PDF Popup] Attempting setFormFieldValues with:', adobeValueEntries.slice(0, 3));
                        await currentPDFAPIs.setFormFieldValues({ formFieldValues: adobeValueEntries });
                console.log('[PDF Popup] Applied field values via Adobe API setFormFieldValues');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
                    } catch (apiError) {
                console.warn('[PDF Popup] Adobe API setFormFieldValues failed', apiError);
            }
        } else {
            console.log('[PDF Popup] setFormFieldValues not available - apis:', !!currentPDFAPIs, 'method:', typeof currentPDFAPIs?.setFormFieldValues);
        }

        // Method 2: Try Adobe API updateFormFieldValues
        if (adobeValueEntries.length && currentPDFAPIs && currentPDFAPIs.updateFormFieldValues) {
            try {
                console.log('[PDF Popup] Attempting updateFormFieldValues with:', adobeValueEntries.slice(0, 3));
                await currentPDFAPIs.updateFormFieldValues(adobeValueEntries);
                console.log('[PDF Popup] Applied field values via Adobe API updateFormFieldValues');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
            } catch (apiError) {
                console.warn('[PDF Popup] Adobe API updateFormFieldValues failed', apiError);
            }
        } else {
            console.log('[PDF Popup] updateFormFieldValues not available - apis:', !!currentPDFAPIs, 'method:', typeof currentPDFAPIs?.updateFormFieldValues);
        }

        // Method 3: Try individual field updates
        if (currentPDFAPIs && currentPDFAPIs.updateFormFieldValue) {
            try {
                console.log('[PDF Popup] Attempting individual field updates for', adobeValueEntries.length, 'fields');
                for (const entry of adobeValueEntries.slice(0, 5)) { // Only try first 5 for testing
                    await currentPDFAPIs.updateFormFieldValue(entry.name, entry.value);
                }
                console.log('[PDF Popup] Applied field values via individual updates');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
            } catch (apiError) {
                console.warn('[PDF Popup] Individual field updates failed', apiError);
            }
        } else {
            console.log('[PDF Popup] updateFormFieldValue not available - apis:', !!currentPDFAPIs, 'method:', typeof currentPDFAPIs?.updateFormFieldValue);
        }

        // Method 4: Try viewer setFormFields
                if (currentPDFViewer && currentPDFViewer.setFormFields) {
                    try {
                console.log('[PDF Popup] Attempting viewer setFormFields with:', Object.keys(fieldValues).slice(0, 5));
                await currentPDFViewer.setFormFields(fieldValues);
                        console.log('[PDF Popup] Applied viewer field map');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
                    } catch (viewerError) {
                console.warn('[PDF Popup] Primary setFormFields failed', viewerError);
            }
        } else {
            console.log('[PDF Popup] setFormFields not available - viewer:', !!currentPDFViewer, 'method:', typeof currentPDFViewer?.setFormFields);
        }

        // Method 5: Try alternate viewer format
        if (currentPDFViewer && currentPDFViewer.setFormFields) {
            try {
                const viewerValueMap = mapObjectToViewerFieldValues(fieldValues);
                if (Object.keys(viewerValueMap).length) {
                    console.log('[PDF Popup] Attempting alternate viewer setFormFields with:', Object.keys(viewerValueMap).slice(0, 5));
                                await currentPDFViewer.setFormFields(viewerValueMap);
                                console.log('[PDF Popup] Applied alternate viewer field map');
                    setSaveStatus('success', 'Existing field values applied from the database.');
                    return;
                }
                            } catch (alternateError) {
                                console.warn('[PDF Popup] Alternate setFormFields failed', alternateError);
            }
        }

        // If all methods fail, try to reload PDF with pre-filled values
        console.error('[PDF Popup] All field value application methods failed');
        console.log('[PDF Popup] Attempting to reload PDF with pre-filled values from server');
        
        try {
            // Reload the PDF with pre-filled values from the server endpoint
            const prefilledUrl = appOrigin + '/api/pdf/template/' + localTemplateId + '/' + accountId;
            console.log('[PDF Popup] Reloading PDF from:', prefilledUrl);
            
            // Re-initialize the viewer with the pre-filled PDF
            currentPDFViewer.previewFile({
                content: {
                    location: {
                        url: prefilledUrl
                    }
                },
                metaData: {
                    fileName: "Certificate of Insurance",
                    id: localTemplateId
                }
            });
            
            setSaveStatus('success', 'PDF reloaded with saved field values.');
            console.log('[PDF Popup] PDF reloaded with pre-filled values');
        } catch (reloadError) {
            console.error('[PDF Popup] Failed to reload PDF with pre-filled values:', reloadError);
            setSaveStatus('error', 'Unable to apply saved field values. Fields may not be editable in this PDF.');
        }
    }

    function mapObjectToAdobeFormFieldValues(obj) {
        if (!obj || typeof obj !== 'object') {
            return [];
        }
        return Object.keys(obj).map(name => ({ fieldName: name, value: obj[name] }));
    }

    function normalizeViewerFieldMap(raw) {
        if (!raw || typeof raw !== 'object') {
            return {};
        }
        return Object.keys(raw).reduce((acc, key) => {
            const entry = raw[key];
            if (entry && typeof entry === 'object' && entry.value !== undefined) {
                acc[key] = entry.value;
            } else if (entry && typeof entry === 'object' && entry.defaultValue !== undefined) {
                acc[key] = entry.defaultValue;
            } else {
                acc[key] = entry;
            }
            return acc;
        }, {});
    }

    function mapObjectToViewerFieldValues(obj) {
        if (!obj || typeof obj !== 'object') {
            return {};
        }
        const result = {};
        Object.keys(obj).forEach(name => {
            result[name] = { value: obj[name] };
        });
        return result;
    }

    function normalizeAdobeFieldDefinitions(raw) {
        const source = Array.isArray(raw) ? raw
            : (raw && Array.isArray(raw.formFieldList) ? raw.formFieldList
                : (raw && Array.isArray(raw.data) ? raw.data : []));

        return source.map(item => {
            if (!item) {
                return { name: '', type: 'text', label: '', required: false };
            }

            const name = item.name || item.fieldName || item.id || '';
            const label = item.displayLabel || item.label || name;
            const type = item.type || item.fieldType || 'text';
            const required = Boolean(item.required || item.mandatory);
            const readOnly = Boolean(item.readOnly || item.readonly);
            const defaultValue = item.defaultValue !== undefined ? item.defaultValue : (item.value !== undefined ? item.value : null);

            const normalized = {
                name,
                type,
                label,
                required,
                read_only: readOnly,
                default_value: defaultValue,
            };

            if (Array.isArray(item.options) && item.options.length > 0) {
                normalized.options = item.options.map(option => {
                    if (typeof option === 'string') {
                        return option;
                    }
                    if (option && typeof option === 'object') {
                        if (option.value !== undefined) {
                            return String(option.value);
                        }
                        if (option.displayValue !== undefined) {
                            return String(option.displayValue);
                        }
                    }
                    return String(option ?? '');
                });
            }

            if (Array.isArray(item.locations) && item.locations.length > 0) {
                normalized.locations = item.locations.map(loc => ({
                    page: loc && (loc.pageNumber ?? loc.page ?? null),
                    x: loc && (loc.x ?? loc.left ?? null),
                    y: loc && (loc.y ?? loc.top ?? null),
                }));
            }

            if (item.maxLength !== undefined) {
                normalized.max_length = item.maxLength;
            }

            return normalized;
        });
    }

    function normalizeAdobeFieldValues(raw) {
        if (!raw) {
            return {};
        }

        if (Array.isArray(raw)) {
            return raw.reduce((acc, entry) => {
                if (!entry) {
                    return acc;
                }
                const key = entry.fieldName || entry.name || entry.id;
                if (!key) {
                    return acc;
                }
                const value = entry.value !== undefined ? entry.value
                    : (entry.fieldValue !== undefined ? entry.fieldValue : (entry.defaultValue !== undefined ? entry.defaultValue : ''));
                acc[key] = value;
                return acc;
            }, {});
        }

        if (typeof raw === 'object') {
            if (Array.isArray(raw.formFieldValues)) {
                return normalizeAdobeFieldValues(raw.formFieldValues);
            }
            if (raw.formFieldValues && typeof raw.formFieldValues === 'object') {
                return normalizeAdobeFieldValues(raw.formFieldValues);
            }

            return Object.keys(raw).reduce((acc, key) => {
                const entry = raw[key];
                acc[key] = (entry && typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                return acc;
            }, {});
        }

        return {};
    }

    function collectFieldsFromDOM() {
        try {
            console.log('[PDF Popup] Collecting fields from DOM...');
            const fields = {};
            
            // Look for Adobe PDF form fields in the DOM
            const adobeContainer = popupWindow.document.getElementById('adobe-dc-view');
            if (adobeContainer) {
                // Try to find form fields within the Adobe container
                const inputs = adobeContainer.querySelectorAll('input, textarea, select');
                console.log('[PDF Popup] Found DOM inputs:', inputs.length);
                
                inputs.forEach((input, index) => {
                    if (input.name || input.id) {
                        const fieldName = input.name || input.id || `field_${index}`;
                        fields[fieldName] = input.value || '';
                    }
                });
            }
            
            // Also try to find fields in iframes (Adobe PDF viewer might be in an iframe)
            const iframes = popupWindow.document.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (iframeDoc) {
                        const inputs = iframeDoc.querySelectorAll('input, textarea, select');
                        console.log('[PDF Popup] Found iframe inputs:', inputs.length);
                        
                        inputs.forEach((input, index) => {
                            if (input.name || input.id) {
                                const fieldName = input.name || input.id || `iframe_field_${index}`;
                                fields[fieldName] = input.value || '';
                            }
                        });
                    }
                } catch (e) {
                    // Cross-origin iframe, skip
                    console.log('[PDF Popup] Cannot access iframe content (cross-origin)');
                }
            });
            
            console.log('[PDF Popup] DOM field collection result:', fields);
            return fields;
        } catch (error) {
            console.warn('[PDF Popup] DOM field collection error:', error);
            return {};
        }
    }

    async function collectPdfFieldData() {
        console.log('[PDF Popup] collectPdfFieldData called');
        console.log('[PDF Popup] currentPDFAPIs:', !!currentPDFAPIs);
        console.log('[PDF Popup] currentPDFViewer:', !!currentPDFViewer);
        
        let apis = currentPDFAPIs;
        if ((!apis || typeof apis.getFormFieldList !== 'function') && currentPDFViewer && typeof currentPDFViewer.getAPIs === 'function') {
            try {
                console.log('[PDF Popup] Attempting to get APIs from viewer...');
                apis = await currentPDFViewer.getAPIs();
                currentPDFAPIs = apis;
                console.log('[PDF Popup] Got APIs from viewer:', !!apis);
            } catch (error) {
                console.warn('[PDF Popup] Unable to resolve Adobe APIs on demand', error);
                apis = null;
            }
        }

        let definitions = [];
        let values = {};

        // Try Adobe APIs first
        if (apis && typeof apis.getFormFieldList === 'function') {
            try {
                console.log('[PDF Popup] Calling getFormFieldList...');
                const rawDefinitions = await apis.getFormFieldList({ includeFieldDefinition: true });
                console.log('[PDF Popup] Raw Adobe definitions', rawDefinitions);
                definitions = normalizeAdobeFieldDefinitions(rawDefinitions);
                console.log('[PDF Popup] Normalized definitions', definitions.slice(0, 5));
            } catch (error) {
                console.warn('[PDF Popup] Error fetching Adobe form field definitions', error);
            }
        } else {
            console.log('[PDF Popup] No Adobe APIs available for getFormFieldList');
            console.log('[PDF Popup] Available API methods:', Object.keys(apis || {}));
        }

        if (apis && typeof apis.getFormFieldValues === 'function') {
            try {
                console.log('[PDF Popup] Calling getFormFieldValues...');
                const rawValues = await apis.getFormFieldValues();
                console.log('[PDF Popup] Raw Adobe values', rawValues);
                values = normalizeAdobeFieldValues(rawValues);
                console.log('[PDF Popup] Normalized values', values);
            } catch (error) {
                console.warn('[PDF Popup] Error fetching Adobe form field values', error);
            }
        } else {
            console.log('[PDF Popup] No Adobe APIs available for getFormFieldValues');
            console.log('[PDF Popup] Available API methods:', Object.keys(apis || {}));
        }

        // NOTE: Server-side extraction removed - it was extracting from template, not current PDF state
        // Adobe doesn't provide a way to get current PDF blob programmatically
        // Field values will only be extracted on manual save via save callback

        // Final fallback to server-side field definitions (for field names only)
                    if (Object.keys(values).length === 0) {
            try {
                console.log('[PDF Popup] Using server-side field definitions for field names...');
                const serverFields = popupWindow.PDF_DEBUG?.serverFields || {};
                if (serverFields && Object.keys(serverFields).length > 0) {
                    console.log('[PDF Popup] Field names from server definitions', Object.keys(serverFields).length);
                    // Use server fields as template with empty values
                    values = Object.fromEntries(Object.keys(serverFields).map(key => [key, '']));
                }
            } catch (error) {
                console.warn('[PDF Popup] Server field definitions failed', error);
            }
        }

        console.log('[PDF Popup] Final result - definitions:', definitions.length, 'values:', Object.keys(values).length);
        return { definitions, values };
    }

    // REMOVED: getCurrentPdfContent function
    // Adobe PDF Embed API doesn't provide a way to get current PDF blob programmatically
    // Field extraction will only happen on manual save via save callback

    // No custom form UI - PDF editing only

    // Manual save only - no field extraction function needed

    // Save function is now handled by the save callback

    // Manual save only - no auto-save functionality

    // No field change tracking - manual save only

    // No automatic saves - manual save only

    async function downloadPDF() {
        try {
            const response = await fetch(appOrigin + '/api/pdf/template/' + templateId);
            if (!response.ok) {
                throw new Error('Failed to download PDF');
            }

            const blob = await response.blob();
            const url = popupWindow.URL.createObjectURL(blob);
            const link = doc.createElement('a');
            link.href = url;
            link.download = 'template_' + templateId + '.pdf';
            doc.body.appendChild(link);
            link.click();
            link.remove();
            popupWindow.URL.revokeObjectURL(url);
        } catch (error) {
            popupWindow.alert('Download failed: ' + error.message);
        }
    }

    async function initializeAdobePDF(localTemplateId) {
        if (!adobeContainer) {
            setSaveStatus('error', 'PDF container not available.');
            return;
        }

        adobeContainer.innerHTML = '<div class="h-full flex flex-col items-center justify-center bg-gray-50"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div><p class="text-gray-600">Loading PDF...</p></div>';

        // Load existing field values BEFORE initializing the PDF viewer
        setSaveStatus('info', 'Loading saved field values...');
        await loadExistingFieldValues(localTemplateId);

        const initializeViewer = () => {
            try {
                // Ensure the container exists and is a proper DOM element
                const container = popupWindow.document.getElementById('adobe-dc-view');
                if (!container) {
                    throw new Error('Adobe PDF container not found');
                }
                
                console.log('[PDF Popup] Initializing Adobe PDF viewer with container:', container);
                
                const adobeDCView = new popupWindow.AdobeDC.View({
                    clientId: 'f19373e4703e4d9c98f6d9db1db9a1cb',
                    divId: 'adobe-dc-view',
                });

                adobeDCView.previewFile({
                    content: {
                        location: {
                            url: appOrigin + '/api/pdf/template/' + localTemplateId + '/' + accountId,
                        },
                    },
                    metaData: {
                        fileName: 'Template ' + localTemplateId,
                    },
                }, {
                    embedMode: 'FULL_WINDOW',
                    enableFormFilling: true,
                    showAnnotationTools: false,
                    showDownloadPDF: false,
                    showPrintPDF: false,
                    showSavePDF: true, // Enable save button for field extraction
                    showLeftHandPanel: false,
                    showDisabledSaveButton: false,
                }).then(async adobeViewerController => {
                    currentPDFViewer = adobeViewerController;
                    popupWindow.PDF_DEBUG = popupWindow.PDF_DEBUG || {};
                    popupWindow.PDF_DEBUG.viewer = currentPDFViewer;
                    popupWindow.PDF_DEBUG.state.viewerReady = true;
                    setSaveStatus('info', 'PDF loaded. Applying saved field values...');

                    // Register save callback to extract field values from the actual saved PDF
                    const registerSaveCallback = () => {
                        if (typeof popupWindow.AdobeDC !== 'undefined' && popupWindow.AdobeDC.View) {
                            try {
                                console.log('[PDF Popup] Registering save callback...');
                                adobeDCView.registerCallback(
                                    popupWindow.AdobeDC.View.Enum.CallbackType.SAVE_API,
                                    async (metaData, content, options) => {
                                        console.log('[PDF Popup] Save callback triggered', { metaData, content: content?.length, options });
                                        console.log('[PDF Popup] Content type:', typeof content, 'Length:', content ? content.length : 'null');
                                        
                                        try {
                                            // Convert PDF content to blob
                                            const blob = new Blob([new Uint8Array(content)], { type: 'application/pdf' });
                                            console.log('[PDF Popup] Blob created, size:', blob.size, 'type:', blob.type);
                                            
                                            // Convert blob to base64 for server processing
                                            const reader = new FileReader();
                                            reader.onload = async () => {
                                                const base64Content = reader.result;
                                                console.log('[PDF Popup] Base64 content length:', base64Content.length);
                                                console.log('[PDF Popup] Base64 preview:', base64Content.substring(0, 100) + '...');
                                                
                                                console.log('[PDF Popup] Sending PDF to server for extraction...');
                                                
                                                // Send PDF content to server for extraction and saving
                                                const response = await fetch(appOrigin + '/api/pdf/save-fields', {
                                                    method: 'POST',
                                                    headers: {
                                                        'Content-Type': 'application/json',
                                                    },
                                                    body: JSON.stringify({
                                                        template_id: templateId,
                                                        account_id: accountId,
                                                        pdf_content: base64Content,
                                                        field_values: {} // Will be extracted from PDF
                                                    })
                                                });
                                                
                                                const result = await response.json();
                                                console.log('[PDF Popup] Save result:', result);
                                                
                                                if (result.success) {
                                                    setSaveStatus('success', `Saved ${result.field_count} field values from PDF`);
                                                    console.log('[PDF Popup] Successfully saved extracted field values');
                                                } else {
                                                    setSaveStatus('error', 'Save failed: ' + result.error);
                                                    console.error('[PDF Popup] Save failed:', result.error);
                                                }
                                            };
                                            reader.readAsDataURL(blob);
                                            
                                        } catch (error) {
                                            console.error('[PDF Popup] Error processing saved PDF:', error);
                                            setSaveStatus('error', 'Error processing save: ' + error.message);
                                        }
                                        
                                        return {
                                            code: popupWindow.AdobeDC.View.Enum.ApiResponseCode.SUCCESS,
                                            data: {
                                                metaData: Object.assign(metaData, { updatedAt: new Date().toISOString() })
                                            }
                                        };
                                    },
                                    {
                                        enableFocusPolling: false,
                                        enableAutoSave: false
                                    }
                                );
                                console.log('[PDF Popup] Save callback registered successfully');
                            } catch (callbackError) {
                                console.warn('[PDF Popup] Failed to register save callback:', callbackError);
                            }
                        } else {
                            console.warn('[PDF Popup] AdobeDC not available for save callback registration');
                        }
                    };
                    
                    // Register save callback immediately
                    registerSaveCallback();

                    currentPDFViewer.getAPIs().then(async apis => {
                        currentPDFAPIs = apis;
                        popupWindow.PDF_DEBUG.apis = currentPDFAPIs;
                        
                        console.log('[PDF Popup] Adobe APIs loaded, PDF ready for editing');
                        console.log('[PDF Popup] Available API methods:', Object.keys(apis || {}));
                        setSaveStatus('success', 'PDF loaded. Click on fields to edit, then press Ctrl+S to save.');
                        
                        // Apply saved field values if they exist
                        console.log('[PDF Popup] Checking savedFieldValues:', savedFieldValues);
                        console.log('[PDF Popup] savedFieldValues type:', typeof savedFieldValues);
                        console.log('[PDF Popup] savedFieldValues keys:', savedFieldValues ? Object.keys(savedFieldValues) : 'null');
                        console.log('[PDF Popup] savedFieldValues length:', savedFieldValues ? Object.keys(savedFieldValues).length : 0);
                        
                        if (savedFieldValues && Object.keys(savedFieldValues).length > 0) {
                            console.log('[PDF Popup] Applying saved field values after PDF load');
                            await applySavedFieldValues(savedFieldValues);
                        } else {
                            console.log('[PDF Popup] No saved field values to apply - savedFieldValues:', savedFieldValues);
                        }
                    }).catch(async apiError => {
                        console.warn('[PDF Popup] Unable to access Adobe viewer APIs', apiError);
                        currentPDFAPIs = null;
                        popupWindow.PDF_DEBUG.apis = null;

                        console.log('[PDF Popup] PDF loaded without Adobe APIs');
                        setSaveStatus('info', 'PDF loaded. Use Ctrl+S to save changes.');
                        
                        // Try to apply saved field values even without APIs
                        console.log('[PDF Popup] Checking savedFieldValues (no APIs):', savedFieldValues);
                        if (savedFieldValues && Object.keys(savedFieldValues).length > 0) {
                            console.log('[PDF Popup] Attempting to apply saved field values without APIs');
                            await applySavedFieldValues(savedFieldValues);
                        } else {
                            console.log('[PDF Popup] No saved field values to apply (no APIs) - savedFieldValues:', savedFieldValues);
                        }
                    });
                }).catch(error => {
                    console.error('[PDF Popup] Error loading PDF', error);
                    showPDFError(localTemplateId, error.message || 'The PDF could not be loaded.');
                });
            } catch (error) {
                console.error('[PDF Popup] Adobe PDF Embed initialization error', error);
                showPDFError(localTemplateId, error.message || 'Adobe PDF Embed API failed to initialize.');
            }
        };

        // Wait for Adobe SDK to be fully loaded with better error handling
        const waitForAdobeSDK = () => {
            if (popupWindow.AdobeDC && popupWindow.AdobeDC.View) {
                console.log('[PDF Popup] AdobeDC is available, initializing viewer');
                initializeViewer();
            } else {
                console.log('[PDF Popup] AdobeDC not yet available, waiting...');
                // Check every 100ms for AdobeDC to be available
                const checkInterval = setInterval(() => {
                    if (popupWindow.AdobeDC && popupWindow.AdobeDC.View) {
                        clearInterval(checkInterval);
                        console.log('[PDF Popup] AdobeDC became available, initializing viewer');
                        initializeViewer();
                    }
                }, 100);
                
                // Stop checking after 10 seconds
                setTimeout(() => {
                    clearInterval(checkInterval);
                    if (!popupWindow.AdobeDC || !popupWindow.AdobeDC.View) {
                        console.warn('[PDF Popup] AdobeDC not available after 10 seconds, showing error');
                        showAdobeSDKError(localTemplateId);
                    }
                }, 10000);
            }
        };
        
        // Listen for the SDK ready event as a fallback
        popupWindow.document.addEventListener('adobe_dc_view_sdk.ready', () => {
            console.log('[PDF Popup] Adobe SDK ready event received');
            initializeViewer();
        }, { once: true });
        
        // Start checking for AdobeDC immediately
        waitForAdobeSDK();
    }

    const startViewer = () => {
        setSaveStatus('info', 'Loading Adobe PDF viewer...');
        ensureTailwindStyles().catch(error => {
            console.warn('[PDF Popup] Tailwind stylesheet failed to load for PDF editor popup.', error);
            setSaveStatus('error', 'Tailwind CDN failed to load. Styling may be limited.');
        }).finally(async () => {
            try {
                await ensureAdobePDFSDK();
                await initializeAdobePDF(templateId);
            } catch (error) {
                    console.error('[PDF Popup] Failed to load Adobe SDK', error);
                    setSaveStatus('error', error.message || 'Adobe PDF Embed API failed to load.');
                    showPDFError(templateId, error.message || 'Adobe PDF Embed API failed to load.');
            }
        });
    };

    if (popupWindow.document.readyState === 'complete') {
        startViewer();
    } else {
        popupWindow.addEventListener('load', startViewer, { once: true });
    }
}


        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
