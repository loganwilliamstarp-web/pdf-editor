<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Certificate Management System</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>PDF</text></svg>">
    <script src="https://cdn.tailwindcss.com" defer></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
</head>
<body>
    <div class="min-h-screen bg-gray-100">
        <header class="bg-white shadow-sm">
            <div class="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8 flex justify-between items-center">
                <h1 class="text-2xl font-bold text-gray-900">
                    Certificate Management System <span class="text-gray-500 text-sm" id="accountId">Loading...</span>
                </h1>
                <nav class="flex space-x-4">
                    <button onclick="showTab('master')" id="masterTab" class="px-3 py-2 rounded-md text-sm font-medium bg-indigo-600 text-white">
                        Master Certificates
                    </button>
                    <button onclick="showTab('holders')" id="holdersTab" class="px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50">
                        Certificate Holders
                    </button>
                    <button onclick="showTab('generated')" id="generatedTab" class="px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50">
                        Generated Certificates
                    </button>
                </nav>
            </div>
        </header>

        <main class="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
            <!-- Master Certificates Tab -->
            <div id="masterContent" class="bg-white shadow overflow-hidden sm:rounded-lg p-6">
                <h2 class="text-xl font-semibold text-gray-900 mb-4">Master Certificates (Templates)</h2>
                
                <div id="templatesList">
                    <p class="text-gray-600">Loading templates...</p>
                </div>
            </div>

            <!-- Certificate Holders Tab -->
            <div id="holdersContent" class="bg-white shadow overflow-hidden sm:rounded-lg p-6" style="display: none;">
                <h2 class="text-xl font-semibold text-gray-900 mb-4">Certificate Holders</h2>
                <p class="text-gray-600">This section will allow you to manage recipients of certificates. (Coming soon!)</p>
            </div>

            <!-- Generated Certificates Tab -->
            <div id="generatedContent" class="bg-white shadow overflow-hidden sm:rounded-lg p-6" style="display: none;">
                <h2 class="text-xl font-semibold text-gray-900 mb-4">Generated Certificates</h2>
                <p class="text-gray-600">This section will display certificates generated from templates for specific holders. (Coming soon!)</p>
            </div>
        </main>
    </div>

    <script>
        // Get account ID from URL
        function getAccountId() {
            const path = window.location.pathname;
            const pathParts = path.split('/').filter(part => part);
            return pathParts[0] || '001000000000001';
        }

        // Initialize the app
        function initApp() {
            const accountId = getAccountId();
            document.getElementById('accountId').textContent = `(${accountId})`;
            loadTemplates();
        }

        // Show tab content
        function showTab(tab) {
            // Hide all content
            document.getElementById('masterContent').style.display = 'none';
            document.getElementById('holdersContent').style.display = 'none';
            document.getElementById('generatedContent').style.display = 'none';
            
            // Remove active class from all tabs
            document.getElementById('masterTab').className = 'px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50';
            document.getElementById('holdersTab').className = 'px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50';
            document.getElementById('generatedTab').className = 'px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50';
            
            // Show selected content and highlight tab
            document.getElementById(tab + 'Content').style.display = 'block';
            document.getElementById(tab + 'Tab').className = 'px-3 py-2 rounded-md text-sm font-medium bg-indigo-600 text-white';
        }

        // Load templates
        async function loadTemplates() {
            try {
                const accountId = getAccountId();
                console.log('Loading templates for account:', accountId);
                const response = await fetch(`/api/account/${accountId}/templates`);
                const data = await response.json();
                console.log('Templates response:', data);
                
                const templatesList = document.getElementById('templatesList');
                if (data.success && data.templates && data.templates.length > 0) {
                    templatesList.innerHTML = `
                        <ul class="divide-y divide-gray-200">
                            ${data.templates.map(template => `
                                <li class="py-4 flex items-center justify-between">
                                    <div class="flex items-center">
                                        <div class="w-6 h-6 text-gray-500 mr-3">PDF</div>
                                        <div>
                                            <p class="text-sm font-medium text-gray-900">${template.template_name}</p>
                                            <p class="text-sm text-gray-500">Type: ${template.template_type}</p>
                                        </div>
                                    </div>
                                    <button onclick="editTemplate('${template.id}')" class="inline-flex items-center px-3 py-1.5 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700">
                                        Edit
                                    </button>
                                </li>
                            `).join('')}
                        </ul>
                    `;
                } else {
                    templatesList.innerHTML = '<p class="text-gray-600">No templates found.</p>';
                }
            } catch (error) {
                console.error('Error loading templates:', error);
                document.getElementById('templatesList').innerHTML = `<p class="text-red-600">Error loading templates: ${error.message}</p>`;
            }
        }

        // Edit template with Adobe PDF Editor (Popup Window)
        function editTemplate(templateId) {
            openPDFEditorWindow(templateId);
        }

        // Open PDF Editor in Popup Window
        function openPDFEditorWindow(templateId) {
    const accountId = getAccountId();
    const windowFeatures = 'width=1200,height=800,scrollbars=yes,resizable=yes,toolbar=no,menubar=no,location=no,status=no';
    const popupWindow = window.open('', `pdfEditor_${templateId}`, windowFeatures);

    if (!popupWindow) {
        alert('Popup blocked! Please allow popups for this site and try again.');
        return;
    }

    const popupHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>PDF Editor - Template</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>PDF</text></svg>">
</head>
<body class="bg-gray-100">
    <div class="h-screen flex flex-col">
        <!-- Header -->
        <header class="bg-white shadow-sm border-b">
            <div class="px-6 py-4 flex justify-between items-center">
                <h1 class="text-xl font-semibold text-gray-900">PDF Editor</h1>
                <div class="flex space-x-3">
                    <button id="showFormBtn" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-purple-600 hover:bg-purple-700">Show Form Editor</button>
                    <button id="saveBtn" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700">Save Fields</button>
                    <button id="downloadBtn" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700">Download PDF</button>
                    <button id="closeBtn" class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50">Close</button>
                </div>
            </div>
        </header>

        <!-- Info Bar -->
        <div class="bg-blue-50 border-b px-6 py-3">
            <p class="text-sm text-blue-800">
                <strong>Reliable Auto-Save:</strong> Click on any field in the PDF to edit it.
                Changes are automatically saved every 10 seconds, when you switch tabs, or when you close the window.
            </p>
        </div>

        <!-- PDF Container -->
        <div class="flex-1 p-6">
            <div id="pdfEditorContainer" class="h-full border border-gray-300 rounded-lg bg-white">
                <!-- PDF Viewer -->
                <div id="adobe-dc-view" style="width: 100%; height: 60%;"></div>
                
                <!-- Custom Form Editor -->
                <div id="formEditor" class="hidden bg-gray-50 border-t border-gray-300 p-4" style="height: 40%;">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold text-gray-800">Form Field Editor</h3>
                        <button id="toggleFormBtn" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm transition-colors">
                            Hide Form
                        </button>
                    </div>
                    <div id="formFieldsContainer" class="space-y-2 max-h-full overflow-y-auto">
                        <!-- Form fields will be dynamically generated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="bg-white border-t px-6 py-3">
            <div class="flex justify-between items-center">
            <div id="saveStatus" class="text-sm text-blue-600">Preparing Adobe PDF viewer...</div>
                <div id="autoSaveStatus" class="text-xs text-gray-500">Auto-save: Ready</div>
            </div>
        </div>
    </div>
</body>
</html>`;

    popupWindow.document.open('text/html');
    popupWindow.document.write(popupHTML);
    popupWindow.document.close();

    initializePDFEditorPopup(popupWindow, { templateId, accountId, appOrigin: window.location.origin });

    popupWindow.focus();
}

function initializePDFEditorPopup(popupWindow, context) {
    const { templateId, accountId, appOrigin: forcedOrigin } = context;
    const doc = popupWindow.document;

    if (!doc) {
        console.error('[PDF Popup] document unavailable');
        return;
    }

    const appOrigin = forcedOrigin
        || (popupWindow.opener && popupWindow.opener.location && popupWindow.opener.location.origin)
        || (popupWindow.location && popupWindow.location.origin)
        || window.location.origin;
    console.log('[PDF Popup] init context', { templateId, accountId, appOrigin });

    popupWindow.PDF_DEBUG = popupWindow.PDF_DEBUG || {};
    popupWindow.PDF_DEBUG.context = { templateId, accountId, appOrigin };
    popupWindow.PDF_DEBUG.state = popupWindow.PDF_DEBUG.state || {};

    let currentPDFViewer = null;
    let currentPDFAPIs = null;
    popupWindow.PDF_DEBUG.state.viewerReady = false;
    
    // Auto-save and reliable save mechanisms
    let autoSaveInterval = null;
    let lastSaveTime = null;
    let pendingChanges = false;
    let isSaving = false;
    let savedFieldValues = null; // Store field values to apply when PDF loads
    let lastKnownFieldValues = {}; // Track last known values for change detection

    const saveBtn = doc.getElementById('saveBtn');
    const downloadBtn = doc.getElementById('downloadBtn');
    const closeBtn = doc.getElementById('closeBtn');
    const showFormBtn = doc.getElementById('showFormBtn');
    const toggleFormBtn = doc.getElementById('toggleFormBtn');
    const saveStatusEl = doc.getElementById('saveStatus');
    const autoSaveStatusEl = doc.getElementById('autoSaveStatus');
    const adobeContainer = doc.getElementById('adobe-dc-view');
    const formEditor = doc.getElementById('formEditor');
    const formFieldsContainer = doc.getElementById('formFieldsContainer');

    function setSaveStatus(status, message) {
        if (!saveStatusEl) {
            return;
        }
        saveStatusEl.className = 'text-sm';
        if (status === 'info') {
            saveStatusEl.classList.add('text-blue-600');
        } else if (status === 'success') {
            saveStatusEl.classList.add('text-green-600');
        } else if (status === 'error') {
            saveStatusEl.classList.add('text-red-600');
        }
        saveStatusEl.textContent = message;
    }

    function setAutoSaveStatus(message) {
        if (autoSaveStatusEl) {
            autoSaveStatusEl.textContent = message;
        }
    }

    popupWindow.addEventListener('error', function(event) {
        setSaveStatus('error', 'Runtime error: ' + event.message);
        if (event && event.error) {
            console.error('[PDF Popup] uncaught error', event.error);
        } else {
            console.error('[PDF Popup] uncaught error', event.message);
        }
    });

    if (closeBtn) {
        closeBtn.addEventListener('click', async () => {
            // Save any pending changes before closing
            if (pendingChanges) {
                console.log('[PDF Popup] Closing window, saving pending changes...');
                await savePDFFields(false);
            }
            stopAutoSave();
            popupWindow.close();
        });
    }

    if (saveBtn) {
        saveBtn.addEventListener('click', () => savePDFFields());
    }

    if (downloadBtn) {
        downloadBtn.addEventListener('click', () => downloadPDF());
    }

    function ensureTailwindStyles() {
        if (popupWindow.tailwind) {
            console.log('[PDF Popup] Tailwind already available');
            return Promise.resolve();
        }

        const existing = doc.getElementById('tailwind-popup-script');
        if (existing) {
            console.log('[PDF Popup] Waiting for existing Tailwind script to load');
            return new Promise((resolve, reject) => {
                existing.addEventListener('load', () => resolve(), { once: true });
                existing.addEventListener('error', () => reject(new Error('Tailwind CDN failed to load')), { once: true });
            });
        }

        return new Promise((resolve, reject) => {
            console.log('[PDF Popup] Injecting Tailwind CDN script');
            const script = doc.createElement('script');
            script.id = 'tailwind-popup-script';
            script.src = 'https://cdn.tailwindcss.com';
            script.defer = true;
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Tailwind CDN failed to load'));
            doc.head.appendChild(script);
        });
    }

    function ensureAdobePDFSDK() {
        if (popupWindow.AdobeDC && popupWindow.AdobeDC.View) {
            console.log('[PDF Popup] Adobe SDK already available');
            return Promise.resolve();
        }

        const existing = doc.getElementById('adobe-pdf-viewer-sdk');
        if (existing) {
            console.log('[PDF Popup] Waiting for existing Adobe SDK script');
            return new Promise((resolve, reject) => {
                existing.addEventListener('load', () => resolve(), { once: true });
                existing.addEventListener('error', () => reject(new Error('Adobe PDF Embed API failed to load')), { once: true });
            });
        }

        return new Promise((resolve, reject) => {
            console.log('[PDF Popup] Injecting Adobe PDF Embed SDK script');
            const script = doc.createElement('script');
            script.id = 'adobe-pdf-viewer-sdk';
            script.src = 'https://acrobatservices.adobe.com/view-sdk/viewer.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Adobe PDF Embed API failed to load'));
            doc.head.appendChild(script);
        });
    }

    function showAdobeSDKError(localTemplateId) {
        if (!adobeContainer) {
            return;
        }
        adobeContainer.innerHTML = '<div class="h-full flex flex-col items-center justify-center bg-gray-50"><div class="text-center p-8"><div class="text-6xl mb-4">PDF</div><h3 class="text-lg font-semibold text-gray-900 mb-2">PDF Editor Ready</h3><p class="text-gray-600 mb-4">Template ID: ' + localTemplateId + '</p><div class="space-y-2 text-sm text-gray-500 mb-6"><p>-  Click on form fields to edit them</p><p>-  Use the Save Fields button to save your changes</p><p>-  Data is automatically saved to the database</p></div><div class="p-4 bg-blue-50 rounded-lg"><p class="text-blue-800 text-sm"><strong>Adobe PDF Embed API:</strong> Demo mode - Form fields are simulated for testing.</p></div></div></div>';
        setSaveStatus('info', 'Adobe viewer unavailable. Demo mode is active.');

        currentPDFViewer = {
            getFormFields: async function() {
                return {
                    company_name: 'Sample Company',
                    policy_number: 'POL-123456',
                    effective_date: '01/01/2025',
                    expiration_date: '12/31/2025',
                    insured_name: 'John Doe',
                    address: '123 Main St, City, State 12345'
                };
            },
            setFormFields: async function(fields) {
                console.log('[PDF Popup] Demo mode setting form fields', fields);
                return true;
            }
        };
    }

    function showPDFError(localTemplateId, errorMessage) {
        if (!adobeContainer) {
            return;
        }
        adobeContainer.innerHTML = '<div class="h-full flex flex-col items-center justify-center bg-gray-50"><div class="text-center p-8"><div class="text-6xl mb-4">Warning</div><h3 class="text-lg font-semibold text-gray-900 mb-2">PDF Loading Error</h3><p class="text-gray-600 mb-4">Template ID: ' + localTemplateId + '</p><p class="text-red-600 text-sm mb-6">Error: ' + errorMessage + '</p><div class="space-y-2 text-sm text-gray-500 mb-6"><p>-  PDF file may not be available</p><p>-  Check template storage configuration</p><p>-  Try refreshing the page</p></div><button id="retryLoadBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Retry Loading PDF</button></div></div>';

        const retryBtn = doc.getElementById('retryLoadBtn');
        if (retryBtn) {
            retryBtn.addEventListener('click', () => startViewer());
        }

        setSaveStatus('error', errorMessage || 'Failed to load the PDF template.');

        currentPDFViewer = {
            getFormFields: async function() {
                return {
                    company_name: 'Sample Company',
                    policy_number: 'POL-123456',
                    effective_date: '01/01/2025',
                    expiration_date: '12/31/2025',
                    insured_name: 'John Doe',
                    address: '123 Main St, City, State 12345'
                };
            },
            setFormFields: async function(fields) {
                console.log('[PDF Popup] Fallback: Setting form fields', fields);
                return true;
            }
        };
    }

    async function loadExistingFieldValues(localTemplateId) {
        try {
            const url = appOrigin + '/api/pdf/get-fields/' + localTemplateId + '/' + accountId;
            console.log('[PDF Popup] Loading field values from:', url);
            
            const response = await fetch(url);
            console.log('[PDF Popup] Load response status:', response.status);
            
            const data = await response.json();
            console.log('[PDF Popup] Load response data:', data);

            // Store server field definitions for fallback
            if (data.success && data.form_fields && Array.isArray(data.form_fields)) {
                const serverFields = {};
                data.form_fields.forEach(field => {
                    if (field.name) {
                        serverFields[field.name] = field.default_value || '';
                    }
                });
                popupWindow.PDF_DEBUG = popupWindow.PDF_DEBUG || {};
                popupWindow.PDF_DEBUG.serverFields = serverFields;
                console.log('[PDF Popup] Stored server field definitions:', Object.keys(serverFields).length);
            }

            if (data.success && data.field_values && Object.keys(data.field_values).length > 0) {
                console.log('[PDF Popup] Loading existing field values', data.field_values);
                savedFieldValues = data.field_values; // Store for later application
                return data.field_values;
            } else {
                console.log('[PDF Popup] No existing field values found');
                console.log('[PDF Popup] Field values object:', data.field_values);
                console.log('[PDF Popup] Field values keys:', Object.keys(data.field_values || {}));
                savedFieldValues = null;
                return null;
            }
        } catch (error) {
            console.error('[PDF Popup] Error loading existing field values', error);
            savedFieldValues = null;
            return null;
        }
    }

    async function applySavedFieldValues(fieldValues) {
        if (!fieldValues || Object.keys(fieldValues).length === 0) {
            setSaveStatus('info', 'PDF ready for editing. Save to store your changes.');
            return;
        }

        console.log('[PDF Popup] Applying saved field values', fieldValues);

        // Wait for PDF to be fully loaded
        await new Promise(resolve => setTimeout(resolve, 2000));

        const adobeValueEntries = mapObjectToAdobeFormFieldValues(fieldValues);
        console.log('[PDF Popup] Prepared Adobe value entries', adobeValueEntries);

        // Method 1: Try Adobe API setFormFieldValues
        if (adobeValueEntries.length && currentPDFAPIs && currentPDFAPIs.setFormFieldValues) {
            try {
                await currentPDFAPIs.setFormFieldValues({ formFieldValues: adobeValueEntries });
                console.log('[PDF Popup] Applied field values via Adobe API setFormFieldValues');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
            } catch (apiError) {
                console.warn('[PDF Popup] Adobe API setFormFieldValues failed', apiError);
            }
        }

        // Method 2: Try Adobe API updateFormFieldValues
        if (adobeValueEntries.length && currentPDFAPIs && currentPDFAPIs.updateFormFieldValues) {
            try {
                await currentPDFAPIs.updateFormFieldValues(adobeValueEntries);
                console.log('[PDF Popup] Applied field values via Adobe API updateFormFieldValues');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
            } catch (apiError) {
                console.warn('[PDF Popup] Adobe API updateFormFieldValues failed', apiError);
            }
        }

        // Method 3: Try individual field updates
        if (currentPDFAPIs && currentPDFAPIs.updateFormFieldValue) {
            try {
                for (const entry of adobeValueEntries) {
                    await currentPDFAPIs.updateFormFieldValue(entry.name, entry.value);
                }
                console.log('[PDF Popup] Applied field values via individual updates');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
            } catch (apiError) {
                console.warn('[PDF Popup] Individual field updates failed', apiError);
            }
        }

        // Method 4: Try viewer setFormFields
        if (currentPDFViewer && currentPDFViewer.setFormFields) {
            try {
                await currentPDFViewer.setFormFields(fieldValues);
                console.log('[PDF Popup] Applied viewer field map');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
            } catch (viewerError) {
                console.warn('[PDF Popup] Primary setFormFields failed', viewerError);
            }
        }

        // Method 5: Try alternate viewer format
        if (currentPDFViewer && currentPDFViewer.setFormFields) {
            try {
                const viewerValueMap = mapObjectToViewerFieldValues(fieldValues);
                if (Object.keys(viewerValueMap).length) {
                    await currentPDFViewer.setFormFields(viewerValueMap);
                    console.log('[PDF Popup] Applied alternate viewer field map');
                    setSaveStatus('success', 'Existing field values applied from the database.');
                    return;
                }
            } catch (alternateError) {
                console.warn('[PDF Popup] Alternate setFormFields failed', alternateError);
            }
        }

        // If all methods fail, show error
        console.error('[PDF Popup] All field value application methods failed');
        setSaveStatus('error', 'Unable to apply saved field values. Fields may not be editable in this PDF.');
    }

    function mapObjectToAdobeFormFieldValues(obj) {
        if (!obj || typeof obj !== 'object') {
            return [];
        }
        return Object.keys(obj).map(name => ({ fieldName: name, value: obj[name] }));
    }

    function normalizeViewerFieldMap(raw) {
        if (!raw || typeof raw !== 'object') {
            return {};
        }
        return Object.keys(raw).reduce((acc, key) => {
            const entry = raw[key];
            if (entry && typeof entry === 'object' && entry.value !== undefined) {
                acc[key] = entry.value;
            } else if (entry && typeof entry === 'object' && entry.defaultValue !== undefined) {
                acc[key] = entry.defaultValue;
            } else {
                acc[key] = entry;
            }
            return acc;
        }, {});
    }

    function mapObjectToViewerFieldValues(obj) {
        if (!obj || typeof obj !== 'object') {
            return {};
        }
        const result = {};
        Object.keys(obj).forEach(name => {
            result[name] = { value: obj[name] };
        });
        return result;
    }

    function normalizeAdobeFieldDefinitions(raw) {
        const source = Array.isArray(raw) ? raw
            : (raw && Array.isArray(raw.formFieldList) ? raw.formFieldList
                : (raw && Array.isArray(raw.data) ? raw.data : []));

        return source.map(item => {
            if (!item) {
                return { name: '', type: 'text', label: '', required: false };
            }

            const name = item.name || item.fieldName || item.id || '';
            const label = item.displayLabel || item.label || name;
            const type = item.type || item.fieldType || 'text';
            const required = Boolean(item.required || item.mandatory);
            const readOnly = Boolean(item.readOnly || item.readonly);
            const defaultValue = item.defaultValue !== undefined ? item.defaultValue : (item.value !== undefined ? item.value : null);

            const normalized = {
                name,
                type,
                label,
                required,
                read_only: readOnly,
                default_value: defaultValue,
            };

            if (Array.isArray(item.options) && item.options.length > 0) {
                normalized.options = item.options.map(option => {
                    if (typeof option === 'string') {
                        return option;
                    }
                    if (option && typeof option === 'object') {
                        if (option.value !== undefined) {
                            return String(option.value);
                        }
                        if (option.displayValue !== undefined) {
                            return String(option.displayValue);
                        }
                    }
                    return String(option ?? '');
                });
            }

            if (Array.isArray(item.locations) && item.locations.length > 0) {
                normalized.locations = item.locations.map(loc => ({
                    page: loc && (loc.pageNumber ?? loc.page ?? null),
                    x: loc && (loc.x ?? loc.left ?? null),
                    y: loc && (loc.y ?? loc.top ?? null),
                }));
            }

            if (item.maxLength !== undefined) {
                normalized.max_length = item.maxLength;
            }

            return normalized;
        });
    }

    function normalizeAdobeFieldValues(raw) {
        if (!raw) {
            return {};
        }

        if (Array.isArray(raw)) {
            return raw.reduce((acc, entry) => {
                if (!entry) {
                    return acc;
                }
                const key = entry.fieldName || entry.name || entry.id;
                if (!key) {
                    return acc;
                }
                const value = entry.value !== undefined ? entry.value
                    : (entry.fieldValue !== undefined ? entry.fieldValue : (entry.defaultValue !== undefined ? entry.defaultValue : ''));
                acc[key] = value;
                return acc;
            }, {});
        }

        if (typeof raw === 'object') {
            if (Array.isArray(raw.formFieldValues)) {
                return normalizeAdobeFieldValues(raw.formFieldValues);
            }
            if (raw.formFieldValues && typeof raw.formFieldValues === 'object') {
                return normalizeAdobeFieldValues(raw.formFieldValues);
            }

            return Object.keys(raw).reduce((acc, key) => {
                const entry = raw[key];
                acc[key] = (entry && typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                return acc;
            }, {});
        }

        return {};
    }

    function collectFieldsFromDOM() {
        try {
            console.log('[PDF Popup] Collecting fields from DOM...');
            const fields = {};
            
            // Look for Adobe PDF form fields in the DOM
            const adobeContainer = popupWindow.document.getElementById('adobe-dc-view');
            if (adobeContainer) {
                // Try to find form fields within the Adobe container
                const inputs = adobeContainer.querySelectorAll('input, textarea, select');
                console.log('[PDF Popup] Found DOM inputs:', inputs.length);
                
                inputs.forEach((input, index) => {
                    if (input.name || input.id) {
                        const fieldName = input.name || input.id || `field_${index}`;
                        fields[fieldName] = input.value || '';
                    }
                });
            }
            
            // Also try to find fields in iframes (Adobe PDF viewer might be in an iframe)
            const iframes = popupWindow.document.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (iframeDoc) {
                        const inputs = iframeDoc.querySelectorAll('input, textarea, select');
                        console.log('[PDF Popup] Found iframe inputs:', inputs.length);
                        
                        inputs.forEach((input, index) => {
                            if (input.name || input.id) {
                                const fieldName = input.name || input.id || `iframe_field_${index}`;
                                fields[fieldName] = input.value || '';
                            }
                        });
                    }
                } catch (e) {
                    // Cross-origin iframe, skip
                    console.log('[PDF Popup] Cannot access iframe content (cross-origin)');
                }
            });
            
            console.log('[PDF Popup] DOM field collection result:', fields);
            return fields;
        } catch (error) {
            console.warn('[PDF Popup] DOM field collection error:', error);
            return {};
        }
    }

    async function collectPdfFieldData() {
        console.log('[PDF Popup] collectPdfFieldData called');
        console.log('[PDF Popup] currentPDFAPIs:', !!currentPDFAPIs);
        console.log('[PDF Popup] currentPDFViewer:', !!currentPDFViewer);
        
        let apis = currentPDFAPIs;
        if ((!apis || typeof apis.getFormFieldList !== 'function') && currentPDFViewer && typeof currentPDFViewer.getAPIs === 'function') {
            try {
                console.log('[PDF Popup] Attempting to get APIs from viewer...');
                apis = await currentPDFViewer.getAPIs();
                currentPDFAPIs = apis;
                console.log('[PDF Popup] Got APIs from viewer:', !!apis);
            } catch (error) {
                console.warn('[PDF Popup] Unable to resolve Adobe APIs on demand', error);
                apis = null;
            }
        }

        let definitions = [];
        let values = {};

        // Try Adobe APIs first
        if (apis && typeof apis.getFormFieldList === 'function') {
            try {
                console.log('[PDF Popup] Calling getFormFieldList...');
                const rawDefinitions = await apis.getFormFieldList({ includeFieldDefinition: true });
                console.log('[PDF Popup] Raw Adobe definitions', rawDefinitions);
                definitions = normalizeAdobeFieldDefinitions(rawDefinitions);
                console.log('[PDF Popup] Normalized definitions', definitions.slice(0, 5));
            } catch (error) {
                console.warn('[PDF Popup] Error fetching Adobe form field definitions', error);
            }
        } else {
            console.log('[PDF Popup] No Adobe APIs available for getFormFieldList');
            console.log('[PDF Popup] Available API methods:', Object.keys(apis || {}));
        }

        if (apis && typeof apis.getFormFieldValues === 'function') {
            try {
                console.log('[PDF Popup] Calling getFormFieldValues...');
                const rawValues = await apis.getFormFieldValues();
                console.log('[PDF Popup] Raw Adobe values', rawValues);
                values = normalizeAdobeFieldValues(rawValues);
                console.log('[PDF Popup] Normalized values', values);
            } catch (error) {
                console.warn('[PDF Popup] Error fetching Adobe form field values', error);
            }
        } else {
            console.log('[PDF Popup] No Adobe APIs available for getFormFieldValues');
            console.log('[PDF Popup] Available API methods:', Object.keys(apis || {}));
        }

        // Fallback to server-side field extraction if Adobe APIs don't work
        if (Object.keys(values).length === 0) {
            try {
                console.log('[PDF Popup] Attempting server-side field extraction...');
                const pdfContent = await getCurrentPdfContent();
                if (pdfContent) {
                    const response = await fetch(appOrigin + '/api/extract-fields', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            pdf_content: pdfContent
                        })
                    });
                    
                    const result = await response.json();
                    console.log('[PDF Popup] Server extraction result:', result);
                    
                    if (result.success && result.form_data) {
                        console.log('[PDF Popup] Successfully extracted', result.field_count, 'fields from PDF');
                        values = result.form_data;
                    }
                }
            } catch (error) {
                console.warn('[PDF Popup] Server-side extraction failed:', error);
            }
        }

        // Final fallback to server-side field definitions
        if (Object.keys(values).length === 0) {
            try {
                console.log('[PDF Popup] Using server-side field definitions...');
                const serverFields = popupWindow.PDF_DEBUG?.serverFields || {};
                if (serverFields && Object.keys(serverFields).length > 0) {
                    console.log('[PDF Popup] Values from server definitions', Object.keys(serverFields).length);
                    values = serverFields;
                }
            } catch (error) {
                console.warn('[PDF Popup] Server field definitions failed', error);
            }
        }

        console.log('[PDF Popup] Final result - definitions:', definitions.length, 'values:', Object.keys(values).length);
        return { definitions, values };
    }

    async function getCurrentPdfContent() {
        try {
            // Get the current PDF content from the Adobe viewer
            if (currentPDFViewer && typeof currentPDFViewer.getPDFStream === 'function') {
                const pdfStream = await currentPDFViewer.getPDFStream();
                return pdfStream;
            }
            
            // Alternative: fetch the PDF from the server
            const response = await fetch(appOrigin + '/api/pdf/template/' + templateId);
            if (response.ok) {
                const arrayBuffer = await response.arrayBuffer();
                const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                return 'data:application/pdf;base64,' + base64;
            }
        } catch (error) {
            console.warn('[PDF Popup] Failed to get PDF content:', error);
        }
        return null;
    }

    async function savePDFFields(showStatus = true) {
        if (isSaving) {
            console.log('[PDF Popup] Save already in progress, skipping...');
            return false;
        }

        isSaving = true;
        
        if (showStatus && saveBtn && saveStatusEl) {
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
        setSaveStatus('info', 'Saving field values...');
        }

        try {
            if (!currentPDFViewer) {
                if (showStatus) {
                setSaveStatus('error', 'PDF viewer not available.');
                }
                return false;
            }

            const data = await collectPdfFieldData();
            const fieldValuesPayload = (data.values && typeof data.values === 'object') ? data.values : {};
            
            // Check if there are actual changes to save
            if (Object.keys(fieldValuesPayload).length === 0) {
                if (showStatus) {
                    setSaveStatus('info', 'No changes to save.');
                }
                return true;
            }

            const body = {
                template_id: templateId,
                account_id: accountId,
                field_values: fieldValuesPayload,
            };

            if (Array.isArray(data.definitions) && data.definitions.length > 0) {
                body.form_fields = data.definitions;
            }

            console.log('[PDF Popup] Saving field values', body);
            console.log('[PDF Popup] Save URL:', appOrigin + '/api/pdf/save-fields');

            const response = await fetch(appOrigin + '/api/pdf/save-fields', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(body),
            });

            console.log('[PDF Popup] Save response status:', response.status);
            const result = await response.json();
            console.log('[PDF Popup] Save response', result);

            if (result.success) {
                lastSaveTime = new Date();
                pendingChanges = false;
                lastKnownFieldValues = { ...fieldValuesPayload }; // Update last known values
                if (showStatus) {
                setSaveStatus('success', 'Field values saved successfully.');
                }
                return true;
            } else {
                if (showStatus) {
                setSaveStatus('error', 'Save failed: ' + result.error);
                }
                return false;
            }
        } catch (error) {
            console.error('[PDF Popup] Save error:', error);
            if (showStatus) {
            setSaveStatus('error', 'Save error: ' + error.message);
            }
            return false;
        } finally {
            isSaving = false;
            if (showStatus && saveBtn) {
            saveBtn.disabled = false;
            saveBtn.textContent = 'Save Fields';
            }
        }
    }

    // Auto-save functionality
    function startAutoSave() {
        if (autoSaveInterval) {
            clearInterval(autoSaveInterval);
        }
        
        autoSaveInterval = setInterval(async () => {
            if (pendingChanges && !isSaving) {
                console.log('[PDF Popup] Auto-saving...');
                setAutoSaveStatus('Auto-save: Saving...');
                const success = await savePDFFields(false); // Silent save
                if (success) {
                    setAutoSaveStatus('Auto-save: Saved');
                    setTimeout(() => setAutoSaveStatus('Auto-save: Ready'), 2000);
                } else {
                    setAutoSaveStatus('Auto-save: Failed');
                    setTimeout(() => setAutoSaveStatus('Auto-save: Ready'), 3000);
                }
            }
        }, 10000); // Auto-save every 10 seconds
        
        console.log('[PDF Popup] Auto-save started (every 10 seconds)');
        setAutoSaveStatus('Auto-save: Active');
    }

    function stopAutoSave() {
        if (autoSaveInterval) {
            clearInterval(autoSaveInterval);
            autoSaveInterval = null;
            console.log('[PDF Popup] Auto-save stopped');
            setAutoSaveStatus('Auto-save: Stopped');
        }
    }

    // Track form field changes
    function trackFieldChanges() {
        if (currentPDFAPIs && currentPDFAPIs.addEventListener) {
            try {
                currentPDFAPIs.addEventListener('formFieldValueChanged', () => {
                    pendingChanges = true;
                    setAutoSaveStatus('Auto-save: Changes detected');
                    console.log('[PDF Popup] Form field changed, marking for save');
                });
            } catch (error) {
                console.warn('[PDF Popup] Could not add form field change listener:', error);
            }
        }
        
        // Fallback: Poll for changes every 3 seconds with proper change detection
        setInterval(() => {
            if (currentPDFViewer && !isSaving) {
                console.log('[PDF Popup] Polling for field changes...');
                collectPdfFieldData().then(data => {
                    console.log('[PDF Popup] collectPdfFieldData result:', data);
                    const currentValues = data.values || {};
                    console.log('[PDF Popup] Extracted current values:', currentValues);
                    console.log('[PDF Popup] Current values keys:', Object.keys(currentValues));
                    
                    // Compare current values with last known values
                    const hasChanges = JSON.stringify(currentValues) !== JSON.stringify(lastKnownFieldValues);
                    console.log('[PDF Popup] Has changes:', hasChanges);
                    
                    if (hasChanges && Object.keys(currentValues).length > 0) {
                        pendingChanges = true;
                        lastKnownFieldValues = { ...currentValues };
                        setAutoSaveStatus('Auto-save: Changes detected');
                        console.log('[PDF Popup] Field values changed, marking for save');
                        console.log('[PDF Popup] Current values:', currentValues);
                        console.log('[PDF Popup] Last known values:', lastKnownFieldValues);
                    } else if (Object.keys(currentValues).length > 0) {
                        // Log when we have values but no changes detected
                        console.log('[PDF Popup] Field values present but no changes detected');
                        console.log('[PDF Popup] Current values:', currentValues);
                        console.log('[PDF Popup] Last known values:', lastKnownFieldValues);
                    } else {
                        console.log('[PDF Popup] No field values collected');
                    }
                }).catch(error => {
                    console.warn('[PDF Popup] Change detection polling failed:', error);
                });
            } else {
                console.log('[PDF Popup] Polling skipped - viewer:', !!currentPDFViewer, 'saving:', isSaving);
            }
        }, 3000);
    }

    // Reliable save on visibility change
    function setupVisibilitySave() {
        popupWindow.addEventListener('visibilitychange', async () => {
            if (popupWindow.document.visibilityState === 'hidden' && pendingChanges) {
                console.log('[PDF Popup] Window hidden, saving changes...');
                await savePDFFields(false);
            }
        });
    }

    // Reliable save on beforeunload using sendBeacon
    function setupBeforeUnloadSave() {
        popupWindow.addEventListener('beforeunload', (event) => {
            if (pendingChanges && !isSaving) {
                console.log('[PDF Popup] Page unloading, attempting to save...');
                
                // Use sendBeacon for reliable exit saves
                try {
                    // Use the last known field values for exit save
                    const fieldValuesPayload = lastKnownFieldValues || {};
                    
                    if (Object.keys(fieldValuesPayload).length > 0) {
                        const body = JSON.stringify({
                            template_id: templateId,
                            account_id: accountId,
                            field_values: fieldValuesPayload,
                        });
                        
                        // Use sendBeacon for reliable exit saves
                        if (popupWindow.navigator.sendBeacon) {
                            popupWindow.navigator.sendBeacon(
                                appOrigin + '/api/pdf/save-fields',
                                new Blob([body], { type: 'application/json' })
                            );
                            console.log('[PDF Popup] Exit save sent via sendBeacon');
                            pendingChanges = false; // Mark as saved
                        }
                    }
                } catch (error) {
                    console.warn('[PDF Popup] Exit save failed:', error);
                }
            }
        });
    }

    async function downloadPDF() {
        try {
            const response = await fetch(appOrigin + '/api/pdf/template/' + templateId);
            if (!response.ok) {
                throw new Error('Failed to download PDF');
            }

            const blob = await response.blob();
            const url = popupWindow.URL.createObjectURL(blob);
            const link = doc.createElement('a');
            link.href = url;
            link.download = 'template_' + templateId + '.pdf';
            doc.body.appendChild(link);
            link.click();
            link.remove();
            popupWindow.URL.revokeObjectURL(url);
        } catch (error) {
            popupWindow.alert('Download failed: ' + error.message);
        }
    }

    async function initializeAdobePDF(localTemplateId) {
        if (!adobeContainer) {
            setSaveStatus('error', 'PDF container not available.');
            return;
        }

        adobeContainer.innerHTML = '<div class="h-full flex flex-col items-center justify-center bg-gray-50"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div><p class="text-gray-600">Loading PDF...</p></div>';

        // Load existing field values BEFORE initializing the PDF viewer
        setSaveStatus('info', 'Loading saved field values...');
        await loadExistingFieldValues(localTemplateId);

        const initializeViewer = () => {
            try {
                const adobeDCView = new popupWindow.AdobeDC.View({
                    clientId: 'f19373e4703e4d9c98f6d9db1db9a1cb',
                    divId: 'adobe-dc-view',
                });

                adobeDCView.previewFile({
                    content: {
                        location: {
                            url: appOrigin + '/api/pdf/template/' + localTemplateId,
                        },
                    },
                    metaData: {
                        fileName: 'Template ' + localTemplateId,
                    },
                }, {
                    embedMode: 'FULL_WINDOW',
                    enableFormFilling: true,
                    showAnnotationTools: false,
                    showDownloadPDF: false,
                    showPrintPDF: false,
                    showSavePDF: false,
                    showLeftHandPanel: false,
                    showDisabledSaveButton: false,
                }).then(async adobeViewerController => {
                    currentPDFViewer = adobeViewerController;
                    popupWindow.PDF_DEBUG = popupWindow.PDF_DEBUG || {};
                    popupWindow.PDF_DEBUG.viewer = currentPDFViewer;
                    popupWindow.PDF_DEBUG.state.viewerReady = true;
                    setSaveStatus('info', 'PDF loaded. Applying saved field values...');

                    currentPDFViewer.getAPIs().then(async apis => {
                        currentPDFAPIs = apis;
                        popupWindow.PDF_DEBUG.apis = currentPDFAPIs;
                        
                        // Apply saved field values immediately after APIs are ready
                        if (savedFieldValues) {
                            await applySavedFieldValues(savedFieldValues);
                            lastKnownFieldValues = { ...savedFieldValues }; // Initialize last known values
                        } else {
                            setSaveStatus('info', 'PDF ready for editing. Save to store your changes.');
                        }
                        
                        // Set up reliable save mechanisms
                        trackFieldChanges();
                        startAutoSave();
                        setupVisibilitySave();
                        setupBeforeUnloadSave();
                        
                        console.log('[PDF Popup] Reliable save mechanisms initialized');
                    }).catch(async apiError => {
                        console.warn('[PDF Popup] Unable to access Adobe viewer APIs', apiError);
                        currentPDFAPIs = null;
                        popupWindow.PDF_DEBUG.apis = null;
                        
                        // Apply saved field values even without Adobe APIs
                        if (savedFieldValues) {
                            await applySavedFieldValues(savedFieldValues);
                            lastKnownFieldValues = { ...savedFieldValues }; // Initialize last known values
                        } else {
                            setSaveStatus('info', 'PDF ready for editing. Save to store your changes.');
                        }
                        
                        // Still set up basic save mechanisms even without Adobe APIs
                        startAutoSave();
                        setupVisibilitySave();
                        setupBeforeUnloadSave();
                    });
                }).catch(error => {
                    console.error('[PDF Popup] Error loading PDF', error);
                    showPDFError(localTemplateId, error.message || 'The PDF could not be loaded.');
                });
            } catch (error) {
                console.error('[PDF Popup] Adobe PDF Embed initialization error', error);
                showPDFError(localTemplateId, error.message || 'Adobe PDF Embed API failed to initialize.');
            }
        };

        if (popupWindow.AdobeDC && popupWindow.AdobeDC.View) {
            initializeViewer();
        } else {
            popupWindow.document.addEventListener('adobe_dc_view_sdk.ready', initializeViewer, { once: true });
        }

        popupWindow.setTimeout(() => {
            if (!popupWindow.AdobeDC || !popupWindow.AdobeDC.View) {
                showAdobeSDKError(localTemplateId);
            }
        }, 6000);
    }

    const startViewer = () => {
        setSaveStatus('info', 'Loading Adobe PDF viewer...');
        ensureTailwindStyles().catch(error => {
            console.warn('[PDF Popup] Tailwind stylesheet failed to load for PDF editor popup.', error);
            setSaveStatus('error', 'Tailwind CDN failed to load. Styling may be limited.');
        }).finally(async () => {
            try {
                await ensureAdobePDFSDK();
                await initializeAdobePDF(templateId);
            } catch (error) {
                    console.error('[PDF Popup] Failed to load Adobe SDK', error);
                    setSaveStatus('error', error.message || 'Adobe PDF Embed API failed to load.');
                    showPDFError(templateId, error.message || 'Adobe PDF Embed API failed to load.');
            }
        });
    };

    if (popupWindow.document.readyState === 'complete') {
        startViewer();
    } else {
        popupWindow.addEventListener('load', startViewer, { once: true });
    }
}


        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
