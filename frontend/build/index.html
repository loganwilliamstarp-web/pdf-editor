<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Certificate Management System</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>PDF</text></svg>">
    <script src="https://cdn.tailwindcss.com" defer></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
</head>
<body>
    <div class="min-h-screen bg-gray-100">
        <header class="bg-white shadow-sm">
            <div class="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8 flex justify-between items-center gap-4">
                <h1 class="text-2xl font-bold text-gray-900 flex flex-wrap items-baseline gap-2">
                    <span>Certificate Management System</span>
                    <span class="text-sm text-gray-500" id="accountId">Account: Loading...</span>
                    <span class="hidden text-sm text-gray-400" id="ownerId"></span>
                </h1>
                <div class="flex items-center gap-3">
                    <nav class="flex space-x-4">
                        <button onclick="showTab('master')" id="masterTab" class="px-3 py-2 rounded-md text-sm font-medium bg-indigo-600 text-white">
                            Master Certificates
                        </button>
                        <button onclick="showTab('holders')" id="holdersTab" class="px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50">
                            Certificate Holders
                        </button>
                        <button onclick="showTab('generated')" id="generatedTab" class="px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50">
                            Generated Certificates
                        </button>
                    </nav>
                    <button id="openAgencySettingsBtn" type="button"
                            class="inline-flex items-center rounded-full border border-transparent bg-white p-2 text-gray-500 shadow-sm hover:text-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                            aria-label="Configure agency settings">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                            <path fill-rule="evenodd" d="M11.983 1.574a1 1 0 0 0-1.966 0l-.217 1.086a1 1 0 0 1-1.371.73l-1.02-.413a1 1 0 0 0-1.258.485l-.983 1.7a1 1 0 0 0 .268 1.274l.873.654a1 1 0 0 1 0 1.606l-.873.654a1 1 0 0 0-.268 1.274l.983 1.7a1 1 0 0 0 1.258.485l1.02-.413a1 1 0 0 1 1.371.73l.217 1.086a1 1 0 0 0 1.966 0l.217-1.086a1 1 0 0 1 1.371-.73l1.02.413a1 1 0 0 0 1.258-.485l.983-1.7a1 1 0 0 0-.268-1.274l-.873-.654a1 1 0 0 1 0-1.606l.873-.654a1 1 0 0 0 .268-1.274l-.983-1.7a1 1 0 0 0-1.258-.485l-1.02.413a1 1 0 0 1-1.371-.73l-.217-1.086ZM13 10a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" clip-rule="evenodd"/>
                        </svg>
                    </button>
                </div>
            </div>
        </header>

        <main class="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
            <!-- Master Certificates Tab -->
            <div id="masterContent" class="bg-white shadow overflow-hidden sm:rounded-lg p-6">
                <h2 class="text-xl font-semibold text-gray-900 mb-4">Master Certificates (Templates)</h2>
                
                <div id="templatesList">
                    <p class="text-gray-600">Loading templates...</p>
                </div>
            </div>

        <!-- Certificate Holders Tab -->
        <div id="holdersContent" class="bg-white shadow overflow-hidden sm:rounded-lg p-6 space-y-6" style="display: none;">
            <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
                <div>
                    <h2 class="text-xl font-semibold text-gray-900">Certificate Holders</h2>
                    <p class="text-gray-600">Add and manage the contacts who should receive certificates for this Salesforce account.</p>
                </div>
                <div class="flex gap-3">
                    <button id="refreshHoldersBtn"
                            class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
                        Refresh
                    </button>
                    <button id="openHolderModalBtn"
                            class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                        + Add Certificate Holder
                    </button>
                </div>
            </div>

            <p id="holderSelectionSummary" class="text-sm text-gray-500">No certificate holders selected.</p>

            <div id="holderList" class="space-y-4">
                <p class="text-gray-600">Loading certificate holders...</p>
            </div>
        </div>

            <!-- Generated Certificates Tab -->
            <div id="generatedContent" class="bg-white shadow overflow-hidden sm:rounded-lg p-6" style="display: none;">
                <h2 class="mb-4 text-xl font-semibold text-gray-900">Generated Certificates</h2>
                <p class="text-gray-600">This section will display certificates generated from templates for specific holders. (Coming soon!)</p>
                <div id="agencySettingsSummary" class="mt-4 rounded-md border border-dashed border-gray-300 bg-gray-50 p-4 text-sm text-gray-600">
                    <p class="text-sm text-gray-500">No agency details saved yet. Use the gear icon to configure them.</p>
                </div>
            </div>
        </main>
    </div>

    <!-- Certificate Holder Modal -->
    <div id="holderModal" class="fixed inset-0 z-50 hidden items-center justify-center">
        <div id="holderModalOverlay" class="absolute inset-0 bg-gray-900 bg-opacity-50"></div>
        <div class="relative z-10 mx-auto w-full max-w-3xl px-4">
            <div class="bg-white shadow-xl rounded-lg overflow-hidden">
                <div class="flex items-center justify-between border-b px-6 py-4">
                    <div>
                        <h3 id="holderModalTitle" class="text-lg font-semibold text-gray-900">Add Certificate Holder</h3>
                        <p class="text-sm text-gray-500">Provide the details for the recipient who should receive certificates.</p>
                    </div>
                    <button id="holderModalCloseBtn" type="button" class="text-gray-400 hover:text-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 rounded-full p-1">
                        <span class="sr-only">Close</span>
                        âœ•
                    </button>
                </div>
                <form id="holderForm" class="px-6 py-5 space-y-5">
                    <div id="holderFormAlert" class="hidden"></div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="md:col-span-2">
                            <label for="holderName" class="block text-sm font-medium text-gray-700">Name <span class="text-red-500">*</span></label>
                            <input id="holderName" name="name" type="text" required autocomplete="off"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                   placeholder="ACME Inc. - Insurance Department">
                        </div>

                        <div class="md:col-span-2">
                            <label for="holderMasterRemarks" class="block text-sm font-medium text-gray-700">Master Remarks</label>
                            <textarea id="holderMasterRemarks" name="master_remarks" rows="3"
                                      class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                      placeholder="Instructions or notes to include on generated certificates."></textarea>
                        </div>

                        <div class="md:col-span-2">
                            <label for="holderAddress1" class="block text-sm font-medium text-gray-700">Address Line 1</label>
                            <input id="holderAddress1" name="address_line1" type="text" autocomplete="off"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                   placeholder="123 Main Street">
                        </div>

                        <div>
                            <label for="holderCity" class="block text-sm font-medium text-gray-700">City</label>
                            <input id="holderCity" name="city" type="text" autocomplete="off"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                        </div>
                        <div>
                            <label for="holderState" class="block text-sm font-medium text-gray-700">State</label>
                            <select id="holderState" name="state"
                                    class="mt-1 block w-full rounded-md border-gray-300 bg-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                                <option value="">Select state</option>
                            </select>
                        </div>

                        <div>
                            <label for="holderEmail" class="block text-sm font-medium text-gray-700">Email</label>
                            <input id="holderEmail" name="email" type="email" autocomplete="off"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                   placeholder="certificates@example.com">
                        </div>
                        <div>
                            <label for="holderPhone" class="block text-sm font-medium text-gray-700">Phone</label>
                            <input id="holderPhone" name="phone" type="tel" autocomplete="off"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                   placeholder="(123) 456-7890">
                        </div>
                    </div>

                    <div class="flex justify-between gap-3 pt-4 border-t border-gray-200">
                        <button id="holderResetBtn" type="button"
                                class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
                            Clear Form
                        </button>
                        <div class="flex gap-3">
                            <button id="holderCancelBtn" type="button"
                                    class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50">
                                Cancel
                            </button>
                            <button id="holderSubmitBtn" type="submit"
                                    class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                                Save Certificate Holder
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Agency Settings Modal -->
    <div id="agencySettingsModal" class="fixed inset-0 z-50 hidden items-center justify-center">
        <div id="agencySettingsModalOverlay" class="absolute inset-0 bg-gray-900 bg-opacity-50"></div>
        <div class="relative z-10 mx-auto w-full max-w-2xl px-4">
            <div class="overflow-hidden rounded-lg bg-white shadow-xl">
                <div class="flex items-center justify-between border-b px-6 py-4">
                    <div>
                        <h3 class="text-lg font-semibold text-gray-900">Agency Settings</h3>
                        <p class="text-sm text-gray-500">Store agency details used on generated certificates.</p>
                    </div>
                    <button id="agencySettingsCloseBtn" type="button"
                            class="rounded-full p-1 text-gray-400 hover:text-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                        <span class="sr-only">Close</span>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 0 1 1.414 0L10 8.586l4.293-4.293a1 1 0 0 1 1.414 1.414L11.414 10l4.293 4.293a1 1 0 0 1-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 0 1-1.414-1.414L8.586 10 4.293 5.707a1 1 0 0 1 0-1.414Z" clip-rule="evenodd"/>
                        </svg>
                    </button>
                </div>
                <form id="agencySettingsForm" class="space-y-5 px-6 py-5">
                    <div class="grid grid-cols-1 gap-4 md:grid-cols-2">
                        <div class="md:col-span-2">
                            <label for="agencyName" class="block text-sm font-medium text-gray-700">Agency Name</label>
                            <input id="agencyName" name="agency_name" type="text" autocomplete="organization"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                   placeholder="Acme Insurance Agency">
                        </div>
                        <div class="md:col-span-2">
                            <label for="agencyStreet" class="block text-sm font-medium text-gray-700">Street Address</label>
                            <input id="agencyStreet" name="agency_street" type="text" autocomplete="address-line1"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                   placeholder="123 Main Street">
                        </div>
                        <div>
                            <label for="agencySuite" class="block text-sm font-medium text-gray-700">Suite Number</label>
                            <input id="agencySuite" name="agency_suite" type="text" autocomplete="address-line2"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                   placeholder="Suite 400">
                        </div>
                        <div>
                            <label for="agencyCity" class="block text-sm font-medium text-gray-700">City</label>
                            <input id="agencyCity" name="agency_city" type="text" autocomplete="address-level2"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                   placeholder="Atlanta">
                        </div>
                        <div>
                            <label for="agencyState" class="block text-sm font-medium text-gray-700">State</label>
                            <select id="agencyState" name="agency_state"
                                    class="mt-1 block w-full rounded-md border-gray-300 bg-white shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
                                <option value="">Select state</option>
                            </select>
                        </div>
                        <div>
                            <label for="agencyZip" class="block text-sm font-medium text-gray-700">Zip Code</label>
                            <input id="agencyZip" name="agency_zip" type="text" inputmode="numeric" autocomplete="postal-code"
                                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
                                   placeholder="30301">
                        </div>
                    </div>
                    <div>
                        <label for="agencySignaturePad" class="block text-sm font-medium text-gray-700">Agent Signature</label>
                        <div class="mt-2 rounded-md border border-gray-200 bg-white">
                            <canvas id="agencySignaturePad" class="w-full" style="height: 200px;"></canvas>
                        </div>
                        <div class="mt-2 flex items-center justify-between text-xs text-gray-500">
                            <span>Use your mouse or touch to sign.</span>
                            <button id="agencySignatureClearBtn" type="button" class="font-medium text-indigo-600 hover:text-indigo-500">Clear signature</button>
                        </div>
                    </div>
                    <div class="flex justify-end space-x-3 border-t pt-4">
                        <button id="agencySettingsCancelBtn" type="button"
                                class="rounded-md border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50">
                            Cancel
                        </button>
                        <button type="submit"
                                class="inline-flex justify-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                            Save
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script>
        const DEFAULT_STATE_OPTIONS = [
            { code: 'AL', name: 'Alabama' }, { code: 'AK', name: 'Alaska' }, { code: 'AZ', name: 'Arizona' },
            { code: 'AR', name: 'Arkansas' }, { code: 'CA', name: 'California' }, { code: 'CO', name: 'Colorado' },
            { code: 'CT', name: 'Connecticut' }, { code: 'DE', name: 'Delaware' }, { code: 'DC', name: 'District of Columbia' },
            { code: 'FL', name: 'Florida' }, { code: 'GA', name: 'Georgia' }, { code: 'HI', name: 'Hawaii' },
            { code: 'ID', name: 'Idaho' }, { code: 'IL', name: 'Illinois' }, { code: 'IN', name: 'Indiana' },
            { code: 'IA', name: 'Iowa' }, { code: 'KS', name: 'Kansas' }, { code: 'KY', name: 'Kentucky' },
            { code: 'LA', name: 'Louisiana' }, { code: 'ME', name: 'Maine' }, { code: 'MD', name: 'Maryland' },
            { code: 'MA', name: 'Massachusetts' }, { code: 'MI', name: 'Michigan' }, { code: 'MN', name: 'Minnesota' },
            { code: 'MS', name: 'Mississippi' }, { code: 'MO', name: 'Missouri' }, { code: 'MT', name: 'Montana' },
            { code: 'NE', name: 'Nebraska' }, { code: 'NV', name: 'Nevada' }, { code: 'NH', name: 'New Hampshire' },
            { code: 'NJ', name: 'New Jersey' }, { code: 'NM', name: 'New Mexico' }, { code: 'NY', name: 'New York' },
            { code: 'NC', name: 'North Carolina' }, { code: 'ND', name: 'North Dakota' }, { code: 'OH', name: 'Ohio' },
            { code: 'OK', name: 'Oklahoma' }, { code: 'OR', name: 'Oregon' }, { code: 'PA', name: 'Pennsylvania' },
            { code: 'RI', name: 'Rhode Island' }, { code: 'SC', name: 'South Carolina' }, { code: 'SD', name: 'South Dakota' },
            { code: 'TN', name: 'Tennessee' }, { code: 'TX', name: 'Texas' }, { code: 'UT', name: 'Utah' },
            { code: 'VT', name: 'Vermont' }, { code: 'VA', name: 'Virginia' }, { code: 'WA', name: 'Washington' },
            { code: 'WV', name: 'West Virginia' }, { code: 'WI', name: 'Wisconsin' }, { code: 'WY', name: 'Wyoming' }
        ];
        let certificateHolderStateOptions = [...DEFAULT_STATE_OPTIONS];
        let certificateHoldersLoaded = false;
        let certificateHolderCache = [];
        let selectedCertificateHolderIds = new Set();
        let editingCertificateHolderId = null;
        const HOLDER_MODAL_TITLE_DEFAULT = 'Add Certificate Holder';
        const HOLDER_MODAL_TITLE_EDIT = 'Edit Certificate Holder';
        const AGENCY_SETTINGS_STORAGE_PREFIX = 'certificateManager.agencySettings';
        let agencySettings = null;
        let agencySignatureCanvas = null;
        let agencySignatureCtx = null;
        let agencySignatureDrawing = false;
        let agencySignatureHasData = false;

        function getAccountContext() {
            const pathParts = window.location.pathname.split('/').filter(part => part);
            const accountId = pathParts[0] || '001000000000001';
            const ownerId = pathParts[1] || '';
            return { accountId, ownerId };
        }

        function getAccountId() {
            return getAccountContext().accountId;
        }

        function getOwnerId() {
            return getAccountContext().ownerId;
        }

        function getAgencySettingsStorageKey() {
            const { accountId, ownerId } = getAccountContext();
            const ownerSegment = ownerId || 'default';
            return `${AGENCY_SETTINGS_STORAGE_PREFIX}:${accountId}:${ownerSegment}`;
        }

        function getLegacyAgencySettingsStorageKey() {
            const { accountId } = getAccountContext();
            return `${AGENCY_SETTINGS_STORAGE_PREFIX}:${accountId}`;
        }

        // Initialize the app
        function initApp() {
            const accountId = getAccountId();
            const ownerId = getOwnerId();

            const accountEl = document.getElementById('accountId');
            if (accountEl) {
                accountEl.textContent = `Account: ${accountId}`;
            }

            const ownerEl = document.getElementById('ownerId');
            if (ownerEl) {
                if (ownerId) {
                    ownerEl.textContent = `Owner: ${ownerId}`;
                    ownerEl.classList.remove('hidden');
                } else {
                    ownerEl.textContent = '';
                    ownerEl.classList.add('hidden');
                }
            }

            setupAgencySettingsUI();
            setupCertificateHolderUI();
            loadTemplates();
            loadCertificateHolders(true);
        }

        function setupAgencySettingsUI() {
            loadAgencySettingsFromStorage();
            renderAgencyStateOptions();
            updateAgencySettingsSummary();

            const openBtn = document.getElementById('openAgencySettingsBtn');
            if (openBtn) {
                openBtn.addEventListener('click', openAgencySettingsModal);
            }

            const overlay = document.getElementById('agencySettingsModalOverlay');
            if (overlay) {
                overlay.addEventListener('click', () => closeAgencySettingsModal(true));
            }

            const closeBtn = document.getElementById('agencySettingsCloseBtn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => closeAgencySettingsModal(true));
            }

            const cancelBtn = document.getElementById('agencySettingsCancelBtn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => closeAgencySettingsModal(true));
            }

            const form = document.getElementById('agencySettingsForm');
            if (form) {
                form.addEventListener('submit', handleAgencySettingsSubmit);
            }

            const clearBtn = document.getElementById('agencySignatureClearBtn');
            if (clearBtn) {
                clearBtn.addEventListener('click', () => clearAgencySignature());
            }

            document.addEventListener('keydown', handleAgencySettingsKeydown);

            setupAgencySignaturePad();
        }

        function loadAgencySettingsFromStorage() {
            const storageKey = getAgencySettingsStorageKey();
            try {
                let stored = window.localStorage.getItem(storageKey);
                if (!stored) {
                    const legacyKey = getLegacyAgencySettingsStorageKey();
                    if (legacyKey !== storageKey) {
                        stored = window.localStorage.getItem(legacyKey);
                        if (stored) {
                            try {
                                const parsedLegacy = JSON.parse(stored);
                                saveAgencySettingsToStorage(parsedLegacy);
                                agencySettings = parsedLegacy;
                                return;
                            } catch (legacyError) {
                                console.warn('Unable to parse legacy agency settings.', legacyError);
                                stored = null;
                            }
                        }
                    }
                }
                agencySettings = stored ? JSON.parse(stored) : null;
            } catch (error) {
                console.warn('Unable to load agency settings from storage.', error);
                agencySettings = null;
            }
        }

        function saveAgencySettingsToStorage(settings) {
            const storageKey = getAgencySettingsStorageKey();
            try {
                window.localStorage.setItem(storageKey, JSON.stringify(settings));
            } catch (error) {
                console.warn('Unable to persist agency settings.', error);
            }
        }

        function openAgencySettingsModal() {
            const modal = document.getElementById('agencySettingsModal');
            if (!modal) {
                return;
            }

            populateAgencySettingsForm();
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            modal.setAttribute('aria-hidden', 'false');

            requestAnimationFrame(() => {
                resizeAgencySignatureCanvas();
                if (agencySettings && agencySettings.signatureDataUrl) {
                    renderAgencySignatureFromDataUrl(agencySettings.signatureDataUrl);
                } else {
                    clearAgencySignature();
                }
            });

            setTimeout(() => {
                const nameInput = document.getElementById('agencyName');
                if (nameInput) {
                    nameInput.focus();
                }
            }, 50);
        }

        function closeAgencySettingsModal(shouldReset = false) {
            const modal = document.getElementById('agencySettingsModal');
            if (!modal) {
                return;
            }

            modal.classList.add('hidden');
            modal.classList.remove('flex');
            modal.setAttribute('aria-hidden', 'true');

            if (shouldReset) {
                populateAgencySettingsForm();
            }
        }

        function isAgencySettingsModalOpen() {
            const modal = document.getElementById('agencySettingsModal');
            return modal ? !modal.classList.contains('hidden') : false;
        }

        function handleAgencySettingsKeydown(event) {
            if (event.key === 'Escape' && isAgencySettingsModalOpen()) {
                event.preventDefault();
                closeAgencySettingsModal(true);
            }
        }

        function populateAgencySettingsForm() {
            const data = agencySettings || {};
            const setValue = (id, value) => {
                const el = document.getElementById(id);
                if (el) {
                    el.value = value ? String(value) : '';
                }
            };

            setValue('agencyName', data.name);
            setValue('agencyStreet', data.street);
            setValue('agencySuite', data.suite);
            setValue('agencyCity', data.city);
            setValue('agencyZip', data.zip);

            const stateEl = document.getElementById('agencyState');
            if (stateEl) {
                stateEl.value = data.state || '';
            }
        }

        function handleAgencySettingsSubmit(event) {
            event.preventDefault();

            const getValue = id => {
                const el = document.getElementById(id);
                return el ? el.value.trim() : '';
            };

            const stateEl = document.getElementById('agencyState');
            const stateValue = stateEl ? stateEl.value : '';
            let stateName = '';
            if (stateEl && stateValue) {
                const selectedOption = stateEl.options[stateEl.selectedIndex];
                stateName = selectedOption ? selectedOption.text.trim() : '';
            }

            const signatureDataUrl = agencySignatureHasData && agencySignatureCanvas
                ? agencySignatureCanvas.toDataURL('image/png')
                : '';

            const { accountId, ownerId } = getAccountContext();

            agencySettings = {
                accountId,
                ownerId,
                name: getValue('agencyName'),
                street: getValue('agencyStreet'),
                suite: getValue('agencySuite'),
                city: getValue('agencyCity'),
                state: stateValue,
                stateName,
                zip: getValue('agencyZip'),
                signatureDataUrl
            };

            saveAgencySettingsToStorage(agencySettings);
            updateAgencySettingsSummary();
            closeAgencySettingsModal(true);
        }

        function renderAgencyStateOptions() {
            const select = document.getElementById('agencyState');
            if (!select) {
                return;
            }

            const currentValue = select.value || (agencySettings ? agencySettings.state : '');
            const optionsMarkup = ['<option value="">Select state</option>']
                .concat(
                    certificateHolderStateOptions.map(option => `<option value="${option.code}">${option.name}</option>`)
                )
                .join('');

            select.innerHTML = optionsMarkup;

            if (currentValue && certificateHolderStateOptions.some(option => option.code === currentValue)) {
                select.value = currentValue;
            } else {
                select.value = '';
            }

            renderAgencyStateOptions();
        }

        function updateAgencySettingsSummary() {
            const summaryEl = document.getElementById('agencySettingsSummary');
            if (!summaryEl) {
                return;
            }

            if (!agencySettings) {
                summaryEl.innerHTML = '<p class="text-sm text-gray-500">No agency details saved yet. Use the gear icon to configure them.</p>';
                return;
            }

            const lines = [];

            if (agencySettings.name) {
                lines.push(`<p class="text-sm font-medium text-gray-900">${escapeHtml(agencySettings.name)}</p>`);
            }

            const addressParts = [];
            if (agencySettings.street) {
                addressParts.push(agencySettings.street);
            }
            if (agencySettings.suite) {
                addressParts.push(agencySettings.suite);
            }
            const cityStateParts = [];
            if (agencySettings.city) {
                cityStateParts.push(agencySettings.city);
            }
            const stateDisplay = agencySettings.stateName
                ? `${agencySettings.stateName}${agencySettings.state ? ` (${agencySettings.state})` : ''}`
                : agencySettings.state;
            if (stateDisplay) {
                cityStateParts.push(stateDisplay);
            }
            if (cityStateParts.length > 0) {
                addressParts.push(cityStateParts.join(', '));
            }
            if (agencySettings.zip) {
                addressParts.push(agencySettings.zip);
            }

            if (addressParts.length > 0) {
                const escapedParts = addressParts.map(part => escapeHtml(part));
                lines.push(`<p class="mt-1 text-sm text-gray-600">${escapedParts.join('<br>')}</p>`);
            }

            const signatureStatus = agencySettings.signatureDataUrl
                ? 'Signature saved.'
                : 'No signature saved yet.';

            const metaParts = [signatureStatus];
            const ownerId = getOwnerId();
            if (ownerId) {
                metaParts.push(`Owner: ${ownerId}`);
            }

            lines.push(`<p class="mt-2 text-xs text-gray-500">${metaParts.map(part => escapeHtml(part)).join(' Â· ')}</p>`);

            summaryEl.innerHTML = lines.join('');
        }

        function setupAgencySignaturePad() {
            agencySignatureCanvas = document.getElementById('agencySignaturePad');
            if (!agencySignatureCanvas) {
                return;
            }

            agencySignatureCanvas.style.touchAction = 'none';
            agencySignatureCtx = agencySignatureCanvas.getContext('2d');

            agencySignatureCanvas.addEventListener('pointerdown', startAgencySignatureStroke);
            agencySignatureCanvas.addEventListener('pointermove', drawAgencySignatureStroke);
            agencySignatureCanvas.addEventListener('pointerup', endAgencySignatureStroke);
            agencySignatureCanvas.addEventListener('pointerleave', endAgencySignatureStroke);
            window.addEventListener('pointerup', endAgencySignatureStroke);
            window.addEventListener('pointercancel', endAgencySignatureStroke);
        }

        function resizeAgencySignatureCanvas() {
            if (!agencySignatureCanvas || !agencySignatureCtx) {
                return;
            }

            const rect = agencySignatureCanvas.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                return;
            }

            const ratio = window.devicePixelRatio || 1;
            agencySignatureCanvas.width = rect.width * ratio;
            agencySignatureCanvas.height = rect.height * ratio;
            agencySignatureCtx.setTransform(ratio, 0, 0, ratio, 0, 0);
            agencySignatureCtx.lineWidth = 2;
            agencySignatureCtx.lineCap = 'round';
            agencySignatureCtx.lineJoin = 'round';
            agencySignatureCtx.strokeStyle = '#111827';
        }

        function getAgencySignaturePoint(event) {
            if (!agencySignatureCanvas) {
                return { x: 0, y: 0 };
            }
            const rect = agencySignatureCanvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        function startAgencySignatureStroke(event) {
            if (!agencySignatureCtx) {
                return;
            }
            if (event && event.cancelable) {
                event.preventDefault();
            }
            agencySignatureDrawing = true;
            const point = getAgencySignaturePoint(event);
            agencySignatureCtx.beginPath();
            agencySignatureCtx.moveTo(point.x, point.y);
            agencySignatureHasData = true;
        }

        function drawAgencySignatureStroke(event) {
            if (!agencySignatureDrawing || !agencySignatureCtx) {
                return;
            }
            if (event && event.cancelable) {
                event.preventDefault();
            }
            const point = getAgencySignaturePoint(event);
            agencySignatureCtx.lineTo(point.x, point.y);
            agencySignatureCtx.stroke();
        }

        function endAgencySignatureStroke(event) {
            if (!agencySignatureDrawing || !agencySignatureCtx) {
                return;
            }
            if (event && event.cancelable) {
                event.preventDefault();
            }
            agencySignatureDrawing = false;
            agencySignatureCtx.closePath();
        }

        function clearAgencySignature(options = {}) {
            if (!agencySignatureCanvas || !agencySignatureCtx) {
                agencySignatureHasData = false;
                return;
            }
            agencySignatureCtx.clearRect(0, 0, agencySignatureCanvas.width, agencySignatureCanvas.height);
            if (!options.preserveState) {
                agencySignatureHasData = false;
            }
        }

        function renderAgencySignatureFromDataUrl(dataUrl) {
            if (!agencySignatureCanvas || !agencySignatureCtx || !dataUrl) {
                clearAgencySignature();
                return;
            }

            const image = new Image();
            image.onload = () => {
                clearAgencySignature({ preserveState: true });
                agencySignatureCtx.drawImage(image, 0, 0, agencySignatureCanvas.width, agencySignatureCanvas.height);
                agencySignatureHasData = true;
            };
            image.onerror = () => {
                clearAgencySignature();
            };
            image.src = dataUrl;
        }

        function setupCertificateHolderUI() {
            const form = document.getElementById('holderForm');
            if (form) {
                form.addEventListener('submit', submitCertificateHolder);
            }

            const resetBtn = document.getElementById('holderResetBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', resetHolderForm);
            }

            const cancelBtn = document.getElementById('holderCancelBtn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => closeHolderModal(true));
            }

            const closeBtn = document.getElementById('holderModalCloseBtn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => closeHolderModal(true));
            }

            const overlay = document.getElementById('holderModalOverlay');
            if (overlay) {
                overlay.addEventListener('click', () => closeHolderModal(true));
            }

            const openBtn = document.getElementById('openHolderModalBtn');
            if (openBtn) {
                openBtn.addEventListener('click', openHolderModal);
            }

            const refreshBtn = document.getElementById('refreshHoldersBtn');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', () => {
                    certificateHoldersLoaded = false;
                    loadCertificateHolders(true);
                });
            }

            document.addEventListener('keydown', handleHolderModalKeydown);

            renderHolderStateOptions();
            showHolderAlert(); // hide by default
            window.getSelectedCertificateHolderIds = () => Array.from(selectedCertificateHolderIds);
            window.editCertificateHolder = editCertificateHolder;
            updateHolderSelectionSummary();
            closeHolderModal(true); // ensure hidden on load
        }

        // Show tab content
        function showTab(tab) {
            // Hide all content
            document.getElementById('masterContent').style.display = 'none';
            document.getElementById('holdersContent').style.display = 'none';
            document.getElementById('generatedContent').style.display = 'none';
            
            // Remove active class from all tabs
            document.getElementById('masterTab').className = 'px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50';
            document.getElementById('holdersTab').className = 'px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50';
            document.getElementById('generatedTab').className = 'px-3 py-2 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50';
            
            // Show selected content and highlight tab
            document.getElementById(tab + 'Content').style.display = 'block';
            document.getElementById(tab + 'Tab').className = 'px-3 py-2 rounded-md text-sm font-medium bg-indigo-600 text-white';

            if (tab === 'holders') {
                renderHolderStateOptions();
                if (!certificateHoldersLoaded) {
                    loadCertificateHolders(true);
                }
                updateHolderSelectionSummary();
            }
        }

        function renderHolderStateOptions() {
            const select = document.getElementById('holderState');
            if (!select) {
                return;
            }

            const currentValue = select.value;
            const optionsMarkup = ['<option value="">Select state</option>']
                .concat(
                    certificateHolderStateOptions.map(option => `<option value="${option.code}">${option.name}</option>`)
                )
                .join('');

            select.innerHTML = optionsMarkup;

            if (currentValue && certificateHolderStateOptions.some(option => option.code === currentValue)) {
                select.value = currentValue;
            } else {
                select.value = '';
            }
        }

        function showHolderAlert(type, message) {
            const alertEl = document.getElementById('holderFormAlert');
            if (!alertEl) {
                return;
            }

            if (!message) {
                alertEl.className = 'hidden mb-3';
                alertEl.innerHTML = '';
                return;
            }

            const classMap = {
                success: 'border-green-200 bg-green-50 text-green-700',
                error: 'border-red-200 bg-red-50 text-red-700',
                info: 'border-blue-200 bg-blue-50 text-blue-700'
            };
            const styleClass = classMap[type] || classMap.info;
            alertEl.className = `mb-3 rounded-md border px-4 py-3 text-sm ${styleClass}`;
            alertEl.innerHTML = message;
        }

        function resetHolderForm() {
            const form = document.getElementById('holderForm');
            if (form) {
                form.reset();
            }
            renderHolderStateOptions();
            showHolderAlert();
        }

        function updateHolderSelectionSummary(total = null) {
            const summaryEl = document.getElementById('holderSelectionSummary');
            if (!summaryEl) {
                return;
            }

            if (total === null || total === undefined) {
                total = certificateHolderCache.length;
            }

            if (total === 0) {
                summaryEl.textContent = 'No certificate holders available.';
                return;
            }

            const count = selectedCertificateHolderIds.size;
            if (count === 0) {
                summaryEl.textContent = 'No certificate holders selected.';
            } else if (count === 1) {
                summaryEl.textContent = '1 certificate holder selected.';
            } else {
                summaryEl.textContent = `${count} certificate holders selected.`;
            }
        }

        function updateHolderSelectAllState(selectAllEl, checkboxEls) {
            if (!selectAllEl) {
                return;
            }

            const enabledCheckboxes = checkboxEls.filter(cb => !cb.disabled);
            if (enabledCheckboxes.length === 0) {
                selectAllEl.checked = false;
                selectAllEl.indeterminate = false;
                return;
            }

            const checkedCount = enabledCheckboxes.filter(cb => cb.checked).length;
            if (checkedCount === 0) {
                selectAllEl.checked = false;
                selectAllEl.indeterminate = false;
            } else if (checkedCount === enabledCheckboxes.length) {
                selectAllEl.checked = true;
                selectAllEl.indeterminate = false;
            } else {
                selectAllEl.checked = false;
                selectAllEl.indeterminate = true;
            }
        }

        function setupHolderSelectionHandlers(holders) {
            const selectAllEl = document.getElementById('holderSelectAll');
            const checkboxEls = Array.from(document.querySelectorAll('input.holder-select'));

            checkboxEls.forEach(cb => {
                const holderId = cb.dataset.holderId;
                if (holderId && selectedCertificateHolderIds.has(holderId)) {
                    cb.checked = true;
                }
                cb.addEventListener('change', () => {
                    if (holderId) {
                        if (cb.checked) {
                            selectedCertificateHolderIds.add(holderId);
                        } else {
                            selectedCertificateHolderIds.delete(holderId);
                        }
                    }
                    updateHolderSelectAllState(selectAllEl, checkboxEls);
                    updateHolderSelectionSummary(holders.length);
                });
            });

            if (selectAllEl) {
                updateHolderSelectAllState(selectAllEl, checkboxEls);
                selectAllEl.addEventListener('change', () => {
                    const shouldSelect = selectAllEl.checked;
                    checkboxEls.forEach(cb => {
                        if (cb.disabled) {
                            return;
                        }
                        cb.checked = shouldSelect;
                        const holderId = cb.dataset.holderId;
                        if (!holderId) {
                            return;
                        }
                        if (shouldSelect) {
                            selectedCertificateHolderIds.add(holderId);
                        } else {
                            selectedCertificateHolderIds.delete(holderId);
                        }
                    });
                    updateHolderSelectAllState(selectAllEl, checkboxEls);
                    updateHolderSelectionSummary(holders.length);
                });
            }

            updateHolderSelectionSummary(holders.length);
        }

        function populateHolderForm(holder) {
            if (!holder) {
                return;
            }

            renderHolderStateOptions();

            const setValue = (id, value = '') => {
                const el = document.getElementById(id);
                if (el) {
                    el.value = value || '';
                }
            };

            setValue('holderName', holder.name);
            setValue('holderMasterRemarks', holder.master_remarks);
            setValue('holderAddress1', holder.address_line1);
            setValue('holderCity', holder.city);
            setValue('holderEmail', holder.email);
            setValue('holderPhone', holder.phone);

            const stateField = document.getElementById('holderState');
            if (stateField) {
                stateField.value = holder.state || '';
            }
        }

        function editCertificateHolder(holderId) {
            if (!holderId) {
                return;
            }
            const normalizedId = String(holderId);
            const target = certificateHolderCache.find(holder => holder && String(holder.id) === normalizedId);
            if (!target) {
                console.warn('Certificate holder not found for edit:', holderId);
                return;
            }
            openHolderModal(target);
        }

        function isHolderModalOpen() {
            const modal = document.getElementById('holderModal');
            return modal ? !modal.classList.contains('hidden') : false;
        }

        function openHolderModal(existingHolder = null) {
            const modal = document.getElementById('holderModal');
            if (!modal) {
                return;
            }

            const titleEl = document.getElementById('holderModalTitle');
            const submitBtn = document.getElementById('holderSubmitBtn');

            resetHolderForm();

            if (existingHolder && existingHolder.id) {
                editingCertificateHolderId = String(existingHolder.id);
                if (titleEl) {
                    titleEl.textContent = HOLDER_MODAL_TITLE_EDIT;
                }
                if (submitBtn) {
                    submitBtn.textContent = 'Save Changes';
                }
                populateHolderForm(existingHolder);
            } else {
                editingCertificateHolderId = null;
                if (titleEl) {
                    titleEl.textContent = HOLDER_MODAL_TITLE_DEFAULT;
                }
                if (submitBtn) {
                    submitBtn.textContent = 'Save Certificate Holder';
                }
            }

            modal.classList.remove('hidden');
            modal.classList.add('flex');
            modal.setAttribute('aria-hidden', 'false');
            setTimeout(() => {
                const nameInput = document.getElementById('holderName');
                if (nameInput) {
                    nameInput.focus();
                }
            }, 50);
        }

        function closeHolderModal(shouldReset = false) {
            const modal = document.getElementById('holderModal');
            if (!modal) {
                return;
            }
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            modal.setAttribute('aria-hidden', 'true');
            if (shouldReset) {
                editingCertificateHolderId = null;
                const titleEl = document.getElementById('holderModalTitle');
                const submitBtn = document.getElementById('holderSubmitBtn');
                if (titleEl) {
                    titleEl.textContent = HOLDER_MODAL_TITLE_DEFAULT;
                }
                if (submitBtn) {
                    submitBtn.textContent = 'Save Certificate Holder';
                }
                resetHolderForm();
            }
        }

        function handleHolderModalKeydown(event) {
            if (event.key === 'Escape' && isHolderModalOpen()) {
                event.preventDefault();
                closeHolderModal(true);
            }
        }

        function escapeHtml(value) {
            if (value === null || value === undefined) {
                return '';
            }
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function formatValue(value, placeholder = 'N/A') {
            if (value === null || value === undefined) {
                return placeholder;
            }
            const trimmed = String(value).trim();
            return trimmed ? escapeHtml(trimmed) : placeholder;
        }

        function formatDate(value) {
            if (!value) {
                return 'N/A';
            }
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) {
                return 'N/A';
            }
            return date.toLocaleString();
        }

        async function loadCertificateHolders(forceRefresh = false) {
            const holderList = document.getElementById('holderList');
            if (!holderList) {
                return;
            }
            if (!forceRefresh && certificateHoldersLoaded) {
                return;
            }

            const accountId = getAccountId();
            holderList.innerHTML = '<p class="text-gray-600">Loading certificate holders...</p>';

            try {
                const response = await fetch(`/api/account/${accountId}/certificate-holders`);
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Unable to load certificate holders.');
                }

                if (Array.isArray(data.state_options) && data.state_options.length > 0) {
                    certificateHolderStateOptions = data.state_options.map(option => ({
                        code: option.code,
                        name: option.name
                    }));
                    renderHolderStateOptions();
                    renderAgencyStateOptions();
                }

                renderCertificateHolderList(Array.isArray(data.certificate_holders) ? data.certificate_holders : []);
                certificateHoldersLoaded = true;
            } catch (error) {
                holderList.innerHTML = `<p class="text-red-600">Error loading certificate holders: ${escapeHtml(error.message)}</p>`;
                certificateHoldersLoaded = false;
                updateHolderSelectionSummary();
            }
        }

        function renderCertificateHolderList(holders) {
            const holderList = document.getElementById('holderList');
            if (!holderList) {
                return;
            }

            certificateHolderCache = Array.isArray(holders)
                ? holders.map(holder => holder ? { ...holder, id: holder.id ? String(holder.id) : '' } : holder)
                : [];

            if (!holders || holders.length === 0) {
                holderList.innerHTML = '<p class="text-gray-600">No certificate holders yet. Click "+ Add Certificate Holder" to create one.</p>';
                selectedCertificateHolderIds.clear();
                updateHolderSelectionSummary(0);
                return;
            }

            const validHolderIds = new Set();
            holders.forEach(holder => {
                if (holder && holder.id) {
                    validHolderIds.add(String(holder.id));
                }
            });
            selectedCertificateHolderIds = new Set(
                [...selectedCertificateHolderIds].filter(id => validHolderIds.has(id))
            );

            const rows = holders.map(holder => {
                const holderId = holder && holder.id ? String(holder.id) : '';
                const emailMarkup = holder.email
                    ? `<a class="text-indigo-600 hover:text-indigo-700" href="mailto:${encodeURIComponent(holder.email)}">${escapeHtml(holder.email)}</a>`
                    : 'N/A';
                const phoneMarkup = holder.phone ? escapeHtml(holder.phone) : 'N/A';
                const stateLabel = holder.state
                    ? `${escapeHtml(holder.state)}${holder.state_name ? ` (${escapeHtml(holder.state_name)})` : ''}`
                    : 'N/A';
                const isSelectable = Boolean(holderId);
                const checkedAttr = isSelectable && selectedCertificateHolderIds.has(holderId) ? 'checked' : '';
                const disabledAttr = isSelectable ? '' : 'disabled';
                const dataAttr = isSelectable ? `data-holder-id="${escapeHtml(holderId)}"` : '';
                const rowTitleAttr = holder && holder.master_remarks ? ` title="${escapeHtml(holder.master_remarks)}"` : '';
                const rowDataAttr = holderId ? ` data-holder-id="${escapeHtml(holderId)}"` : '';
                const editButton = holderId
                    ? `<button type="button" class="inline-flex items-center px-3 py-1.5 border border-gray-300 text-xs font-medium rounded-md text-indigo-600 bg-white hover:bg-indigo-50" onclick="editCertificateHolder('${escapeHtml(holderId)}')">Edit</button>`
                    : '<span class="text-gray-400 text-xs">N/A</span>';

                return `
                    <tr class="hover:bg-gray-50"${rowTitleAttr}${rowDataAttr}>
                        <td class="px-4 py-3 text-center">
                            <input type="checkbox" class="holder-select h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" ${dataAttr} ${checkedAttr} ${disabledAttr}>
                        </td>
                        <td class="px-4 py-3 text-sm font-medium text-gray-900">${formatValue(holder.name, 'Unnamed Holder')}</td>
                        <td class="px-4 py-3 text-sm text-gray-700">${formatValue(holder.address_line1)}</td>
                        <td class="px-4 py-3 text-sm text-gray-700">${formatValue(holder.city)}</td>
                        <td class="px-4 py-3 text-sm text-gray-700">${stateLabel}</td>
                        <td class="px-4 py-3 text-sm text-gray-700">${emailMarkup}</td>
                        <td class="px-4 py-3 text-sm text-gray-700">${phoneMarkup}</td>
                        <td class="px-4 py-3 text-sm text-right">${editButton}</td>
                    </tr>
                `;
            }).join('');

            holderList.innerHTML = `
                <div class="overflow-x-auto border border-gray-200 rounded-lg shadow-sm">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="px-4 py-3 text-center w-12">
                                    <input id="holderSelectAll" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                </th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Name</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Address Line 1</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">City</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">State</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Email</th>
                                <th scope="col" class="px-4 py-3 text-left text-xs font-semibold text-gray-500 uppercase tracking-wider">Phone</th>
                                <th scope="col" class="px-4 py-3 text-right text-xs font-semibold text-gray-500 uppercase tracking-wider">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-100">
                            ${rows}
                        </tbody>
                    </table>
                </div>
            `;

            setupHolderSelectionHandlers(holders);
        }

        async function submitCertificateHolder(event) {
            event.preventDefault();

            const submitBtn = document.getElementById('holderSubmitBtn');
            const originalBtnText = submitBtn ? submitBtn.textContent : '';
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Saving...';
            }

            showHolderAlert('info', 'Saving certificate holder...');

            const payload = {
                name: document.getElementById('holderName')?.value?.trim() || '',
                master_remarks: document.getElementById('holderMasterRemarks')?.value?.trim() || '',
                address_line1: document.getElementById('holderAddress1')?.value?.trim() || '',
                city: document.getElementById('holderCity')?.value?.trim() || '',
                state: document.getElementById('holderState')?.value?.trim() || '',
                email: document.getElementById('holderEmail')?.value?.trim() || '',
                phone: document.getElementById('holderPhone')?.value?.trim() || ''
            };

            if (payload.state) {
                payload.state = payload.state.toUpperCase();
            }

            Object.keys(payload).forEach(key => {
                if (payload[key] === '') {
                    payload[key] = null;
                }
            });

            const accountId = getAccountId();
            const isEditing = Boolean(editingCertificateHolderId);
            const endpoint = isEditing
                ? `/api/account/${accountId}/certificate-holders/${editingCertificateHolderId}`
                : `/api/account/${accountId}/certificate-holders`;
            const method = isEditing ? 'PUT' : 'POST';

            try {
                const response = await fetch(endpoint, {
                    method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (!result.success) {
                    const messages = Array.isArray(result.errors) && result.errors.length > 0
                        ? result.errors.map(escapeHtml).join('<br>')
                        : escapeHtml(result.error || 'Unable to save certificate holder.');
                    showHolderAlert('error', messages);
                    return;
                }

                const successMessage = isEditing
                    ? 'Certificate holder updated successfully.'
                    : 'Certificate holder saved successfully.';
                showHolderAlert('success', successMessage);
                certificateHoldersLoaded = false;
                await loadCertificateHolders(true);

                setTimeout(() => {
                    closeHolderModal(true);
                }, 700);
            } catch (error) {
                showHolderAlert('error', `Failed to save certificate holder: ${escapeHtml(error.message)}`);
            } finally {
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalBtnText || 'Save Certificate Holder';
                }
            }
        }

        // Load templates
        async function loadTemplates() {
            try {
                const accountId = getAccountId();
                console.log('Loading templates for account:', accountId);
                const response = await fetch(`/api/account/${accountId}/templates`);
                const data = await response.json();
                console.log('Templates response:', data);
                
                const templatesList = document.getElementById('templatesList');
                if (data.success && data.templates && data.templates.length > 0) {
                    templatesList.innerHTML = `
                        <ul class="divide-y divide-gray-200">
                            ${data.templates.map(template => `
                                <li class="py-4 flex items-center justify-between">
                                    <div class="flex items-center">
                                        <div class="w-6 h-6 text-gray-500 mr-3">PDF</div>
                                        <div>
                                            <p class="text-sm font-medium text-gray-900">${template.template_name}</p>
                                            <p class="text-sm text-gray-500">Type: ${template.template_type}</p>
                                        </div>
                                    </div>
                                    <button onclick="editTemplate('${template.id}')" class="inline-flex items-center px-3 py-1.5 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700">
                                        Edit
                                    </button>
                                </li>
                            `).join('')}
                        </ul>
                    `;
                } else {
                    templatesList.innerHTML = '<p class="text-gray-600">No templates found.</p>';
                }
            } catch (error) {
                console.error('Error loading templates:', error);
                document.getElementById('templatesList').innerHTML = `<p class="text-red-600">Error loading templates: ${error.message}</p>`;
            }
        }

        // Edit template with Adobe PDF Editor (Popup Window)
        function editTemplate(templateId) {
            openPDFEditorWindow(templateId);
        }

        // Open PDF Editor in Popup Window
        function openPDFEditorWindow(templateId) {
    const accountId = getAccountId();
    const windowFeatures = 'width=1200,height=800,scrollbars=yes,resizable=yes,toolbar=no,menubar=no,location=no,status=no';
    const popupWindow = window.open('', `pdfEditor_${templateId}`, windowFeatures);

    if (!popupWindow) {
        alert('Popup blocked! Please allow popups for this site and try again.');
        return;
    }

    const popupHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>PDF Editor - Template</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>PDF</text></svg>">
</head>
<body class="bg-gray-100">
    <div class="h-screen flex flex-col">
        <!-- Header -->
        <header class="bg-white shadow-sm border-b">
            <div class="px-6 py-4 flex justify-between items-center">
                <h1 class="text-xl font-semibold text-gray-900">PDF Editor</h1>
                <div class="flex space-x-3">
                    <button id="saveBtn" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-gray-400 hover:bg-gray-500" disabled>Save PDF (Use Ctrl+S)</button>
                    <button id="downloadBtn" class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700">Download PDF</button>
                    <button id="closeBtn" class="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50">Close</button>
                </div>
            </div>
        </header>

        <!-- Info Bar -->
        <div class="bg-blue-50 border-b px-6 py-3">
            <p class="text-sm text-blue-800">
                <strong>PDF Editor:</strong> Click on any field in the PDF to edit it directly.
                <strong>Press Ctrl+S directly in the PDF viewer</strong> to save your changes to the database.
            </p>
        </div>

        <!-- PDF Container -->
        <div class="flex-1 p-6">
            <div id="pdfEditorContainer" class="h-full border border-gray-300 rounded-lg bg-white">
                <!-- PDF Viewer -->
                <div id="adobe-dc-view" style="width: 100%; height: 100%;"></div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="bg-white border-t px-6 py-3">
            <div class="flex justify-between items-center">
            <div id="saveStatus" class="text-sm text-blue-600">Preparing Adobe PDF viewer...</div>
                <div class="text-xs text-gray-500">Press Ctrl+S directly in the PDF viewer to save</div>
            </div>
        </div>
    </div>
</body>
</html>`;

    popupWindow.document.open('text/html');
    popupWindow.document.write(popupHTML);
    popupWindow.document.close();

    initializePDFEditorPopup(popupWindow, { templateId, accountId, appOrigin: window.location.origin });

    popupWindow.focus();
}

function initializePDFEditorPopup(popupWindow, context) {
    const { templateId, accountId, appOrigin: forcedOrigin } = context;
    const doc = popupWindow.document;

    if (!doc) {
        console.error('[PDF Popup] document unavailable');
        return;
    }

    const appOrigin = forcedOrigin
        || (popupWindow.opener && popupWindow.opener.location && popupWindow.opener.location.origin)
        || (popupWindow.location && popupWindow.location.origin)
        || window.location.origin;
    console.log('[PDF Popup] init context', { templateId, accountId, appOrigin });

    popupWindow.PDF_DEBUG = popupWindow.PDF_DEBUG || {};
    popupWindow.PDF_DEBUG.context = { templateId, accountId, appOrigin };
    popupWindow.PDF_DEBUG.state = popupWindow.PDF_DEBUG.state || {};

    let currentPDFViewer = null;
    let currentPDFAPIs = null;
    popupWindow.PDF_DEBUG.state.viewerReady = false;
    
    // Manual save only - no polling or auto-save
    let isSaving = false;
    let savedFieldValues = null; // Store field values to apply when PDF loads

    const saveBtn = doc.getElementById('saveBtn');
    const downloadBtn = doc.getElementById('downloadBtn');
    const closeBtn = doc.getElementById('closeBtn');
    const saveStatusEl = doc.getElementById('saveStatus');
    const adobeContainer = doc.getElementById('adobe-dc-view');

    function setSaveStatus(status, message) {
        if (!saveStatusEl) {
            return;
        }
        saveStatusEl.className = 'text-sm';
        if (status === 'info') {
            saveStatusEl.classList.add('text-blue-600');
        } else if (status === 'success') {
            saveStatusEl.classList.add('text-green-600');
        } else if (status === 'error') {
            saveStatusEl.classList.add('text-red-600');
        }
        saveStatusEl.textContent = message;
    }

    // No auto-save status function needed

    popupWindow.addEventListener('error', function(event) {
        setSaveStatus('error', 'Runtime error: ' + event.message);
        if (event && event.error) {
            console.error('[PDF Popup] uncaught error', event.error);
        } else {
            console.error('[PDF Popup] uncaught error', event.message);
        }
    });

    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            popupWindow.close();
        });
    }

    if (saveBtn) {
        saveBtn.addEventListener('click', () => {
            // Save button is disabled - show instruction
            setSaveStatus('info', 'Please press Ctrl+S directly in the PDF viewer to save your changes.');
        });
    }

    if (downloadBtn) {
        downloadBtn.addEventListener('click', () => downloadPDF());
    }

    function ensureTailwindStyles() {
        if (popupWindow.tailwind) {
            console.log('[PDF Popup] Tailwind already available');
            return Promise.resolve();
        }

        const existing = doc.getElementById('tailwind-popup-script');
        if (existing) {
            console.log('[PDF Popup] Waiting for existing Tailwind script to load');
            return new Promise((resolve, reject) => {
                existing.addEventListener('load', () => resolve(), { once: true });
                existing.addEventListener('error', () => reject(new Error('Tailwind CDN failed to load')), { once: true });
            });
        }

        return new Promise((resolve, reject) => {
            console.log('[PDF Popup] Injecting Tailwind CDN script');
            const script = doc.createElement('script');
            script.id = 'tailwind-popup-script';
            script.src = 'https://cdn.tailwindcss.com';
            script.defer = true;
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Tailwind CDN failed to load'));
            doc.head.appendChild(script);
        });
    }

    function ensureAdobePDFSDK() {
        if (popupWindow.AdobeDC && popupWindow.AdobeDC.View) {
            console.log('[PDF Popup] Adobe SDK already available');
            return Promise.resolve();
        }

        const existing = doc.getElementById('adobe-pdf-viewer-sdk');
        if (existing) {
            console.log('[PDF Popup] Waiting for existing Adobe SDK script');
            return new Promise((resolve, reject) => {
                existing.addEventListener('load', () => resolve(), { once: true });
                existing.addEventListener('error', () => reject(new Error('Adobe PDF Embed API failed to load')), { once: true });
            });
        }

        return new Promise((resolve, reject) => {
            console.log('[PDF Popup] Injecting Adobe PDF Embed SDK script');
            const script = doc.createElement('script');
            script.id = 'adobe-pdf-viewer-sdk';
            script.src = 'https://acrobatservices.adobe.com/view-sdk/viewer.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Adobe PDF Embed API failed to load'));
            doc.head.appendChild(script);
        });
    }

    function showAdobeSDKError(localTemplateId) {
        if (!adobeContainer) {
            return;
        }
        adobeContainer.innerHTML = '<div class="h-full flex flex-col items-center justify-center bg-gray-50"><div class="text-center p-8"><div class="text-6xl mb-4">PDF</div><h3 class="text-lg font-semibold text-gray-900 mb-2">PDF Editor Ready</h3><p class="text-gray-600 mb-4">Template ID: ' + localTemplateId + '</p><div class="space-y-2 text-sm text-gray-500 mb-6"><p>-  Click on form fields to edit them</p><p>-  Use the Save Fields button to save your changes</p><p>-  Data is automatically saved to the database</p></div><div class="p-4 bg-blue-50 rounded-lg"><p class="text-blue-800 text-sm"><strong>Adobe PDF Embed API:</strong> Demo mode - Form fields are simulated for testing.</p></div></div></div>';
        setSaveStatus('info', 'Adobe viewer unavailable. Demo mode is active.');

        currentPDFViewer = {
            getFormFields: async function() {
                return {
                    company_name: 'Sample Company',
                    policy_number: 'POL-123456',
                    effective_date: '01/01/2025',
                    expiration_date: '12/31/2025',
                    insured_name: 'John Doe',
                    address: '123 Main St, City, State 12345'
                };
            },
            setFormFields: async function(fields) {
                console.log('[PDF Popup] Demo mode setting form fields', fields);
                return true;
            }
        };
    }

    function showPDFError(localTemplateId, errorMessage) {
        if (!adobeContainer) {
            return;
        }
        adobeContainer.innerHTML = '<div class="h-full flex flex-col items-center justify-center bg-gray-50"><div class="text-center p-8"><div class="text-6xl mb-4">Warning</div><h3 class="text-lg font-semibold text-gray-900 mb-2">PDF Loading Error</h3><p class="text-gray-600 mb-4">Template ID: ' + localTemplateId + '</p><p class="text-red-600 text-sm mb-6">Error: ' + errorMessage + '</p><div class="space-y-2 text-sm text-gray-500 mb-6"><p>-  PDF file may not be available</p><p>-  Check template storage configuration</p><p>-  Try refreshing the page</p></div><button id="retryLoadBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Retry Loading PDF</button></div></div>';

        const retryBtn = doc.getElementById('retryLoadBtn');
        if (retryBtn) {
            retryBtn.addEventListener('click', () => startViewer());
        }

        setSaveStatus('error', errorMessage || 'Failed to load the PDF template.');

        currentPDFViewer = {
            getFormFields: async function() {
                return {
                    company_name: 'Sample Company',
                    policy_number: 'POL-123456',
                    effective_date: '01/01/2025',
                    expiration_date: '12/31/2025',
                    insured_name: 'John Doe',
                    address: '123 Main St, City, State 12345'
                };
            },
            setFormFields: async function(fields) {
                console.log('[PDF Popup] Fallback: Setting form fields', fields);
                return true;
            }
        };
    }

    async function loadExistingFieldValues(localTemplateId) {
        try {
            const url = appOrigin + '/api/pdf/get-fields/' + localTemplateId + '/' + accountId;
            console.log('[PDF Popup] Loading field values from:', url);
            
            const response = await fetch(url);
            console.log('[PDF Popup] Load response status:', response.status);
            
            const data = await response.json();
            console.log('[PDF Popup] Load response data:', data);

            // Store server field definitions for fallback
            if (data.success && data.form_fields && Array.isArray(data.form_fields)) {
                const serverFields = {};
                data.form_fields.forEach(field => {
                    if (field.name) {
                        serverFields[field.name] = field.default_value || '';
                    }
                });
                popupWindow.PDF_DEBUG = popupWindow.PDF_DEBUG || {};
                popupWindow.PDF_DEBUG.serverFields = serverFields;
                console.log('[PDF Popup] Stored server field definitions:', Object.keys(serverFields).length);
            }

            if (data.success && data.field_values) {
                console.log('[PDF Popup] Loading existing field values', data.field_values);
                console.log('[PDF Popup] Field values keys:', Object.keys(data.field_values || {}));
                savedFieldValues = data.field_values; // Store for later application
                return data.field_values;
            } else {
                console.log('[PDF Popup] No existing field values found');
                console.log('[PDF Popup] Field values object:', data.field_values);
                savedFieldValues = null;
                return null;
            }
        } catch (error) {
            console.error('[PDF Popup] Error loading existing field values', error);
            savedFieldValues = null;
            return null;
        }
    }

    async function applySavedFieldValues(fieldValues) {
        if (!fieldValues || Object.keys(fieldValues).length === 0) {
            console.log('[PDF Popup] No field values to apply');
            setSaveStatus('info', 'PDF ready for editing. Save to store your changes.');
            return;
        }
        
        // Check if any fields have non-empty values
        const nonEmptyFields = Object.entries(fieldValues).filter(([key, value]) => value && String(value).trim() !== '');
        console.log('[PDF Popup] Non-empty fields to apply:', nonEmptyFields.length);
        
        if (nonEmptyFields.length === 0) {
            console.log('[PDF Popup] All field values are empty, skipping application');
            setSaveStatus('info', 'PDF ready for editing. Save to store your changes.');
            return;
        }

        console.log('[PDF Popup] Applying saved field values', fieldValues);

        // Wait for PDF to be fully loaded
        await new Promise(resolve => setTimeout(resolve, 2000));

        const adobeValueEntries = mapObjectToAdobeFormFieldValues(fieldValues);
                console.log('[PDF Popup] Prepared Adobe value entries', adobeValueEntries);

        // Method 1: Try Adobe API setFormFieldValues
                if (adobeValueEntries.length && currentPDFAPIs && currentPDFAPIs.setFormFieldValues) {
                    try {
                console.log('[PDF Popup] Attempting setFormFieldValues with:', adobeValueEntries.slice(0, 3));
                        await currentPDFAPIs.setFormFieldValues({ formFieldValues: adobeValueEntries });
                console.log('[PDF Popup] Applied field values via Adobe API setFormFieldValues');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
                    } catch (apiError) {
                console.warn('[PDF Popup] Adobe API setFormFieldValues failed', apiError);
            }
        } else {
            console.log('[PDF Popup] setFormFieldValues not available - apis:', !!currentPDFAPIs, 'method:', typeof currentPDFAPIs?.setFormFieldValues);
        }

        // Method 2: Try Adobe API updateFormFieldValues
        if (adobeValueEntries.length && currentPDFAPIs && currentPDFAPIs.updateFormFieldValues) {
            try {
                console.log('[PDF Popup] Attempting updateFormFieldValues with:', adobeValueEntries.slice(0, 3));
                await currentPDFAPIs.updateFormFieldValues(adobeValueEntries);
                console.log('[PDF Popup] Applied field values via Adobe API updateFormFieldValues');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
            } catch (apiError) {
                console.warn('[PDF Popup] Adobe API updateFormFieldValues failed', apiError);
            }
        } else {
            console.log('[PDF Popup] updateFormFieldValues not available - apis:', !!currentPDFAPIs, 'method:', typeof currentPDFAPIs?.updateFormFieldValues);
        }

        // Method 3: Try individual field updates
        if (currentPDFAPIs && currentPDFAPIs.updateFormFieldValue) {
            try {
                console.log('[PDF Popup] Attempting individual field updates for', adobeValueEntries.length, 'fields');
                for (const entry of adobeValueEntries.slice(0, 5)) { // Only try first 5 for testing
                    await currentPDFAPIs.updateFormFieldValue(entry.name, entry.value);
                }
                console.log('[PDF Popup] Applied field values via individual updates');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
            } catch (apiError) {
                console.warn('[PDF Popup] Individual field updates failed', apiError);
            }
        } else {
            console.log('[PDF Popup] updateFormFieldValue not available - apis:', !!currentPDFAPIs, 'method:', typeof currentPDFAPIs?.updateFormFieldValue);
        }

        // Method 4: Try viewer setFormFields
                if (currentPDFViewer && currentPDFViewer.setFormFields) {
                    try {
                console.log('[PDF Popup] Attempting viewer setFormFields with:', Object.keys(fieldValues).slice(0, 5));
                await currentPDFViewer.setFormFields(fieldValues);
                        console.log('[PDF Popup] Applied viewer field map');
                setSaveStatus('success', 'Existing field values applied from the database.');
                return;
                    } catch (viewerError) {
                console.warn('[PDF Popup] Primary setFormFields failed', viewerError);
            }
        } else {
            console.log('[PDF Popup] setFormFields not available - viewer:', !!currentPDFViewer, 'method:', typeof currentPDFViewer?.setFormFields);
        }

        // Method 5: Try alternate viewer format
        if (currentPDFViewer && currentPDFViewer.setFormFields) {
            try {
                const viewerValueMap = mapObjectToViewerFieldValues(fieldValues);
                if (Object.keys(viewerValueMap).length) {
                    console.log('[PDF Popup] Attempting alternate viewer setFormFields with:', Object.keys(viewerValueMap).slice(0, 5));
                                await currentPDFViewer.setFormFields(viewerValueMap);
                                console.log('[PDF Popup] Applied alternate viewer field map');
                    setSaveStatus('success', 'Existing field values applied from the database.');
                    return;
                }
                            } catch (alternateError) {
                                console.warn('[PDF Popup] Alternate setFormFields failed', alternateError);
                            }
                        }

        // If all methods fail, try to reload PDF with pre-filled values
        console.error('[PDF Popup] All field value application methods failed');
        console.log('[PDF Popup] Attempting to reload PDF with pre-filled values from server');
        console.log('[PDF Popup] localTemplateId:', localTemplateId, 'accountId:', accountId, 'appOrigin:', appOrigin);
        console.log('[PDF Popup] templateId from context:', templateId, 'accountId from context:', accountId);
        
        try {
            // Reload the PDF with pre-filled values from the server endpoint
            const prefilledUrl = appOrigin + '/api/pdf/template/' + templateId + '/' + accountId;
            console.log('[PDF Popup] Reloading PDF from:', prefilledUrl);
            
            // Re-initialize the viewer with the pre-filled PDF
            currentPDFViewer.previewFile({
                content: {
                    location: {
                        url: prefilledUrl
                    }
                },
                metaData: {
                    fileName: "Certificate of Insurance",
                    id: templateId
                }
            });
            
            setSaveStatus('success', 'PDF reloaded with saved field values.');
            console.log('[PDF Popup] PDF reloaded with pre-filled values');
        } catch (reloadError) {
            console.error('[PDF Popup] Failed to reload PDF with pre-filled values:', reloadError);
            setSaveStatus('error', 'Unable to apply saved field values. Fields may not be editable in this PDF.');
        }
    }

    function mapObjectToAdobeFormFieldValues(obj) {
        if (!obj || typeof obj !== 'object') {
            return [];
        }
        return Object.keys(obj).map(name => ({ fieldName: name, value: obj[name] }));
    }

    function normalizeViewerFieldMap(raw) {
        if (!raw || typeof raw !== 'object') {
            return {};
        }
        return Object.keys(raw).reduce((acc, key) => {
            const entry = raw[key];
            if (entry && typeof entry === 'object' && entry.value !== undefined) {
                acc[key] = entry.value;
            } else if (entry && typeof entry === 'object' && entry.defaultValue !== undefined) {
                acc[key] = entry.defaultValue;
            } else {
                acc[key] = entry;
            }
            return acc;
        }, {});
    }

    function mapObjectToViewerFieldValues(obj) {
        if (!obj || typeof obj !== 'object') {
            return {};
        }
        const result = {};
        Object.keys(obj).forEach(name => {
            result[name] = { value: obj[name] };
        });
        return result;
    }

    function normalizeAdobeFieldDefinitions(raw) {
        const source = Array.isArray(raw) ? raw
            : (raw && Array.isArray(raw.formFieldList) ? raw.formFieldList
                : (raw && Array.isArray(raw.data) ? raw.data : []));

        return source.map(item => {
            if (!item) {
                return { name: '', type: 'text', label: '', required: false };
            }

            const name = item.name || item.fieldName || item.id || '';
            const label = item.displayLabel || item.label || name;
            const type = item.type || item.fieldType || 'text';
            const required = Boolean(item.required || item.mandatory);
            const readOnly = Boolean(item.readOnly || item.readonly);
            const defaultValue = item.defaultValue !== undefined ? item.defaultValue : (item.value !== undefined ? item.value : null);

            const normalized = {
                name,
                type,
                label,
                required,
                read_only: readOnly,
                default_value: defaultValue,
            };

            if (Array.isArray(item.options) && item.options.length > 0) {
                normalized.options = item.options.map(option => {
                    if (typeof option === 'string') {
                        return option;
                    }
                    if (option && typeof option === 'object') {
                        if (option.value !== undefined) {
                            return String(option.value);
                        }
                        if (option.displayValue !== undefined) {
                            return String(option.displayValue);
                        }
                    }
                    return String(option ?? '');
                });
            }

            if (Array.isArray(item.locations) && item.locations.length > 0) {
                normalized.locations = item.locations.map(loc => ({
                    page: loc && (loc.pageNumber ?? loc.page ?? null),
                    x: loc && (loc.x ?? loc.left ?? null),
                    y: loc && (loc.y ?? loc.top ?? null),
                }));
            }

            if (item.maxLength !== undefined) {
                normalized.max_length = item.maxLength;
            }

            return normalized;
        });
    }

    function normalizeAdobeFieldValues(raw) {
        if (!raw) {
            return {};
        }

        if (Array.isArray(raw)) {
            return raw.reduce((acc, entry) => {
                if (!entry) {
                    return acc;
                }
                const key = entry.fieldName || entry.name || entry.id;
                if (!key) {
                    return acc;
                }
                const value = entry.value !== undefined ? entry.value
                    : (entry.fieldValue !== undefined ? entry.fieldValue : (entry.defaultValue !== undefined ? entry.defaultValue : ''));
                acc[key] = value;
                return acc;
            }, {});
        }

        if (typeof raw === 'object') {
            if (Array.isArray(raw.formFieldValues)) {
                return normalizeAdobeFieldValues(raw.formFieldValues);
            }
            if (raw.formFieldValues && typeof raw.formFieldValues === 'object') {
                return normalizeAdobeFieldValues(raw.formFieldValues);
            }

            return Object.keys(raw).reduce((acc, key) => {
                const entry = raw[key];
                acc[key] = (entry && typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                return acc;
            }, {});
        }

        return {};
    }

    function collectFieldsFromDOM() {
        try {
            console.log('[PDF Popup] Collecting fields from DOM...');
            const fields = {};
            
            // Look for Adobe PDF form fields in the DOM
            const adobeContainer = popupWindow.document.getElementById('adobe-dc-view');
            if (adobeContainer) {
                // Try to find form fields within the Adobe container
                const inputs = adobeContainer.querySelectorAll('input, textarea, select');
                console.log('[PDF Popup] Found DOM inputs:', inputs.length);
                
                inputs.forEach((input, index) => {
                    if (input.name || input.id) {
                        const fieldName = input.name || input.id || `field_${index}`;
                        fields[fieldName] = input.value || '';
                    }
                });
            }
            
            // Also try to find fields in iframes (Adobe PDF viewer might be in an iframe)
            const iframes = popupWindow.document.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (iframeDoc) {
                        const inputs = iframeDoc.querySelectorAll('input, textarea, select');
                        console.log('[PDF Popup] Found iframe inputs:', inputs.length);
                        
                        inputs.forEach((input, index) => {
                            if (input.name || input.id) {
                                const fieldName = input.name || input.id || `iframe_field_${index}`;
                                fields[fieldName] = input.value || '';
                            }
                        });
                    }
                } catch (e) {
                    // Cross-origin iframe, skip
                    console.log('[PDF Popup] Cannot access iframe content (cross-origin)');
                }
            });
            
            console.log('[PDF Popup] DOM field collection result:', fields);
            return fields;
        } catch (error) {
            console.warn('[PDF Popup] DOM field collection error:', error);
            return {};
        }
    }

    async function collectPdfFieldData() {
        console.log('[PDF Popup] collectPdfFieldData called');
        console.log('[PDF Popup] currentPDFAPIs:', !!currentPDFAPIs);
        console.log('[PDF Popup] currentPDFViewer:', !!currentPDFViewer);
        
        let apis = currentPDFAPIs;
        if ((!apis || typeof apis.getFormFieldList !== 'function') && currentPDFViewer && typeof currentPDFViewer.getAPIs === 'function') {
            try {
                console.log('[PDF Popup] Attempting to get APIs from viewer...');
                apis = await currentPDFViewer.getAPIs();
                currentPDFAPIs = apis;
                console.log('[PDF Popup] Got APIs from viewer:', !!apis);
            } catch (error) {
                console.warn('[PDF Popup] Unable to resolve Adobe APIs on demand', error);
                apis = null;
            }
        }

        let definitions = [];
        let values = {};

        // Try Adobe APIs first
        if (apis && typeof apis.getFormFieldList === 'function') {
            try {
                console.log('[PDF Popup] Calling getFormFieldList...');
                const rawDefinitions = await apis.getFormFieldList({ includeFieldDefinition: true });
                console.log('[PDF Popup] Raw Adobe definitions', rawDefinitions);
                definitions = normalizeAdobeFieldDefinitions(rawDefinitions);
                console.log('[PDF Popup] Normalized definitions', definitions.slice(0, 5));
            } catch (error) {
                console.warn('[PDF Popup] Error fetching Adobe form field definitions', error);
            }
        } else {
            console.log('[PDF Popup] No Adobe APIs available for getFormFieldList');
            console.log('[PDF Popup] Available API methods:', Object.keys(apis || {}));
        }

        if (apis && typeof apis.getFormFieldValues === 'function') {
            try {
                console.log('[PDF Popup] Calling getFormFieldValues...');
                const rawValues = await apis.getFormFieldValues();
                console.log('[PDF Popup] Raw Adobe values', rawValues);
                values = normalizeAdobeFieldValues(rawValues);
                console.log('[PDF Popup] Normalized values', values);
            } catch (error) {
                console.warn('[PDF Popup] Error fetching Adobe form field values', error);
            }
        } else {
            console.log('[PDF Popup] No Adobe APIs available for getFormFieldValues');
            console.log('[PDF Popup] Available API methods:', Object.keys(apis || {}));
        }

        // NOTE: Server-side extraction removed - it was extracting from template, not current PDF state
        // Adobe doesn't provide a way to get current PDF blob programmatically
        // Field values will only be extracted on manual save via save callback

        // Final fallback to server-side field definitions (for field names only)
                    if (Object.keys(values).length === 0) {
            try {
                console.log('[PDF Popup] Using server-side field definitions for field names...');
                const serverFields = popupWindow.PDF_DEBUG?.serverFields || {};
                if (serverFields && Object.keys(serverFields).length > 0) {
                    console.log('[PDF Popup] Field names from server definitions', Object.keys(serverFields).length);
                    // Use server fields as template with empty values
                    values = Object.fromEntries(Object.keys(serverFields).map(key => [key, '']));
                }
            } catch (error) {
                console.warn('[PDF Popup] Server field definitions failed', error);
            }
        }

        console.log('[PDF Popup] Final result - definitions:', definitions.length, 'values:', Object.keys(values).length);
        return { definitions, values };
    }

    // REMOVED: getCurrentPdfContent function
    // Adobe PDF Embed API doesn't provide a way to get current PDF blob programmatically
    // Field extraction will only happen on manual save via save callback

    // No custom form UI - PDF editing only

    // Manual save only - no field extraction function needed

    // Save function is now handled by the save callback

    // Manual save only - no auto-save functionality

    // No field change tracking - manual save only

    // No automatic saves - manual save only

    async function downloadPDF() {
        try {
            // Download the pre-filled PDF with account-specific data
            const response = await fetch(appOrigin + '/api/pdf/template/' + templateId + '/' + accountId);
            if (!response.ok) {
                throw new Error('Failed to download PDF');
            }

            const blob = await response.blob();
            const url = popupWindow.URL.createObjectURL(blob);
            const link = doc.createElement('a');
            link.href = url;
            link.download = 'filled_template_' + templateId + '.pdf';
            doc.body.appendChild(link);
            link.click();
            link.remove();
            popupWindow.URL.revokeObjectURL(url);
        } catch (error) {
            popupWindow.alert('Download failed: ' + error.message);
        }
    }


    function registerSaveCallback(adobeDCView) {
        if (typeof popupWindow.AdobeDC !== 'undefined' && popupWindow.AdobeDC.View) {
            try {
                console.log('[PDF Popup] Registering save callback...');
                adobeDCView.registerCallback(
                    popupWindow.AdobeDC.View.Enum.CallbackType.SAVE_API,
                    async (metaData, content, options) => {
                        console.log('[PDF Popup] Save callback triggered', { metaData, content: content?.length, options });
                        
                        try {
                            // Convert PDF content to blob
                            const blob = new Blob([new Uint8Array(content)], { type: 'application/pdf' });
                            console.log('[PDF Popup] Blob created, size:', blob.size, 'type:', blob.type);
                            
                            // Convert blob to base64 for server processing
                            const reader = new FileReader();
                            reader.onload = async () => {
                                const base64Content = reader.result;
                                console.log('[PDF Popup] Base64 content length:', base64Content.length);
                                
                                console.log('[PDF Popup] Sending PDF to server for extraction...');
                                
                                // Send PDF content to server for extraction and saving
                                const response = await fetch(appOrigin + '/api/pdf/save-fields', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                    },
                                    body: JSON.stringify({
                                        template_id: templateId,
                                        account_id: accountId,
                                        pdf_content: base64Content,
                                        field_values: {} // Will be extracted from PDF
                                    })
                                });
                                
                                const result = await response.json();
                                console.log('[PDF Popup] Save result:', result);
                                
                                if (result.success) {
                                    setSaveStatus('success', `Saved ${result.field_count} field values from PDF`);
                                    console.log('[PDF Popup] Successfully saved extracted field values');
                                } else {
                                    setSaveStatus('error', 'Save failed: ' + result.error);
                                    console.error('[PDF Popup] Save failed:', result.error);
                                }
                            };
                            reader.readAsDataURL(blob);
                            
                        } catch (error) {
                            console.error('[PDF Popup] Error processing saved PDF:', error);
                            setSaveStatus('error', 'Error processing save: ' + error.message);
                        }
                        
                        return {
                            code: popupWindow.AdobeDC.View.Enum.ApiResponseCode.SUCCESS,
                            data: {
                                metaData: Object.assign(metaData, { updatedAt: new Date().toISOString() })
                            }
                        };
                    },
                    {
                        enableFocusPolling: false,
                        enableAutoSave: false
                    }
                );
                console.log('[PDF Popup] Save callback registered successfully');
            } catch (callbackError) {
                console.warn('[PDF Popup] Failed to register save callback:', callbackError);
            }
        } else {
            console.warn('[PDF Popup] AdobeDC not available for save callback registration');
        }
    }

    async function initializeAdobePDF(localTemplateId) {
        if (!adobeContainer) {
            setSaveStatus('error', 'PDF container not available.');
            return;
        }

        adobeContainer.innerHTML = '<div class="h-full flex flex-col items-center justify-center bg-gray-50"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div><p class="text-gray-600">Loading PDF...</p></div>';

        setSaveStatus('info', 'Loading PDF...');

        const initializeViewer = () => {
            try {
                // Ensure the container exists and is a proper DOM element
                const container = popupWindow.document.getElementById('adobe-dc-view');
                if (!container) {
                    throw new Error('Adobe PDF container not found');
                }
                
                console.log('[PDF Popup] Initializing Adobe PDF viewer with container:', container);
                
                const adobeDCView = new popupWindow.AdobeDC.View({
                    clientId: 'f19373e4703e4d9c98f6d9db1db9a1cb',
                    divId: 'adobe-dc-view',
                });

                // Load PDF with pre-filled values from server
                const prefilledUrl = appOrigin + '/api/pdf/template/' + localTemplateId + '/' + accountId;
                console.log('[PDF Popup] Loading PDF with pre-filled values from:', prefilledUrl);
                
                adobeDCView.previewFile({
                    content: {
                        location: {
                            url: prefilledUrl,
                        },
                    },
                    metaData: {
                        fileName: 'Template ' + localTemplateId,
                    },
                }, {
                    embedMode: 'FULL_WINDOW',
                    enableFormFilling: true,
                    showAnnotationTools: false,
                    showDownloadPDF: false,
                    showPrintPDF: false,
                    showSavePDF: true,
                    showLeftHandPanel: false,
                    showDisabledSaveButton: false,
                }).then(async adobeViewerController => {
                    currentPDFViewer = adobeViewerController;
                    popupWindow.PDF_DEBUG = popupWindow.PDF_DEBUG || {};
                    popupWindow.PDF_DEBUG.viewer = currentPDFViewer;
                    popupWindow.PDF_DEBUG.state.viewerReady = true;
                    
                    // Register save callback
                    registerSaveCallback(adobeDCView);
                    
                    currentPDFViewer.getAPIs().then(async apis => {
                        currentPDFAPIs = apis;
                        popupWindow.PDF_DEBUG.apis = currentPDFAPIs;
                        
                        console.log('[PDF Popup] Adobe APIs loaded, PDF ready for editing');
                        console.log('[PDF Popup] Available API methods:', Object.keys(apis || {}));
                        setSaveStatus('success', 'PDF loaded with pre-filled values. Click on fields to edit, then press Ctrl+S to save.');
                    }).catch(async apiError => {
                        console.warn('[PDF Popup] Unable to access Adobe viewer APIs', apiError);
                        currentPDFAPIs = null;
                        popupWindow.PDF_DEBUG.apis = null;
                        
                        console.log('[PDF Popup] PDF loaded without Adobe APIs');
                        setSaveStatus('info', 'PDF loaded with pre-filled values. Use Ctrl+S to save changes.');
                    });
                    
                }).catch(error => {
                    console.error('[PDF Popup] Error loading PDF', error);
                    showPDFError(localTemplateId, error.message || 'The PDF could not be loaded.');
                });
            } catch (error) {
                console.error('[PDF Popup] Adobe PDF Embed initialization error', error);
                showPDFError(localTemplateId, error.message || 'Adobe PDF Embed API failed to initialize.');
            }
        };

        // Wait for Adobe SDK to be fully loaded with better error handling
        const waitForAdobeSDK = () => {
        if (popupWindow.AdobeDC && popupWindow.AdobeDC.View) {
                console.log('[PDF Popup] AdobeDC is available, initializing viewer');
            initializeViewer();
        } else {
                console.log('[PDF Popup] AdobeDC not yet available, waiting...');
                // Check every 100ms for AdobeDC to be available
                const checkInterval = setInterval(() => {
                    if (popupWindow.AdobeDC && popupWindow.AdobeDC.View) {
                        clearInterval(checkInterval);
                        console.log('[PDF Popup] AdobeDC became available, initializing viewer');
                        initializeViewer();
                    }
                }, 100);
                
                // Stop checking after 10 seconds
                setTimeout(() => {
                    clearInterval(checkInterval);
            if (!popupWindow.AdobeDC || !popupWindow.AdobeDC.View) {
                        console.warn('[PDF Popup] AdobeDC not available after 10 seconds, showing error');
                showAdobeSDKError(localTemplateId);
            }
                }, 10000);
            }
        };
        
        // Listen for the SDK ready event as a fallback
        popupWindow.document.addEventListener('adobe_dc_view_sdk.ready', () => {
            console.log('[PDF Popup] Adobe SDK ready event received');
            initializeViewer();
        }, { once: true });
        
        // Start checking for AdobeDC immediately
        waitForAdobeSDK();
    }

    const startViewer = () => {
        setSaveStatus('info', 'Loading Adobe PDF viewer...');
        ensureTailwindStyles().catch(error => {
            console.warn('[PDF Popup] Tailwind stylesheet failed to load for PDF editor popup.', error);
            setSaveStatus('error', 'Tailwind CDN failed to load. Styling may be limited.');
        }).finally(async () => {
            try {
                await ensureAdobePDFSDK();
                await initializeAdobePDF(templateId);
            } catch (error) {
                    console.error('[PDF Popup] Failed to load Adobe SDK', error);
                    setSaveStatus('error', error.message || 'Adobe PDF Embed API failed to load.');
                    showPDFError(templateId, error.message || 'Adobe PDF Embed API failed to load.');
            }
        });
    };

    if (popupWindow.document.readyState === 'complete') {
        startViewer();
    } else {
        popupWindow.addEventListener('load', startViewer, { once: true });
    }
}


        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
